## JS: Регулярные выражения (regex)

### Использование метода тестирования

Регулярные выражения используются в языках программирования для сопоставления частей строк. Вы создаете шаблоны, которые помогут вам в поисках соответсвий.

Если вы хотите найти слово ```"the"``` в строке ```"The dog chased the cat"```, вы можете использовать следующее ругулярное выражение: ```/the/```. Обратите внимание, что кавычки не требуются.

JavaScript имеет несколько способов применения регулярных выражений. Один из способов использования регулярного выражения, это метод ```.test()```. Этот метод берет регулярное выражение, проверяет его наличие в строке (внутри скобок) и возвращает ```true``` или ```false```.

```javascript
let testStr = "Hello World";
let testRegex = /Hello/;
testRegex.test(testStr);
// returns true
```

### Совпадение литеральных строк

В последнем вызове вы искали слово ```"Hello"```, используя регулярное выражение ```/Hello/```. Это регулярное выражение искало буквальное соотвествие строки ```"Hello"```. Любые другие формы ```"Hello"``` не будут совпадалать. Например, регулярное выражение ```/Kevin/``` не будет соответствовать ```"kevin"``` или ```"KEVIN"```.

```javascript
let wrongRegex = /kevin/;
wrongRegex.test("KEVIN");
// Returns false
```

### Сопоставление литеральных строк с различными возможностями

Используя регулярное выражение тип ```/coding/```, вы можете искать шаблон ```"coding"``` в другой строке.

Это мощный инструмент для поиска отдельных строк, но он ограничен только одним шаблоном. Вы можете искать несколько шаблонов с помощью оператора чередования ```alternation``` или ```OR``` оператора: ```|```.

Этот оператор соответствует шаблонам до или после него. Например, если вы хотите сопоставить ```"yes"``` или ```"no"```, регулярное выражение которое тут нужно это ```/yes|no/```.

Вы также можете искать не только два паттерна. Можно добавить больше шаблонов с большим количеством операторов ```OR```, разделяющих их, например ```/yes|no|maybe/```.


### Игнорирование регистра при сопоставлении

До сих пор вы смотрели на регулярные выражения, чтобы сделать литеральные соотвествия строк. Но иногда вам так же нужно будет сопоставить без учета регистра.

Для этого вы можете применять так называемые флаги. Конкретно в случае, когда вам нужно игнорирование регистра - применяется ```i``` флаг. Вы можете использовать его, добавив к регулярному выражению. Примером использования этого флага является  ```/igmorecase/i```.
```javascript
let myString = "freeCodeCamp";
let fccRegex = /freecodecamp/i;
let result = fccRegex.test(myString);
// return true
```

### Извлечение совпадений

До сих пор вы только проверяли, существует ли шаблон или нет в строке. Вы так же можете извлечь фактические совпадения, которые вы нашли с помощью метода ``` .match()```.
```javascript
"Hello, World!".match(/Hello/);
// Returns ["Hello"]
let ourStr = "Regular expressions";
let ourRegex = /expressions/;
ourStr.match(ourRegex);
// Returns ["expressions"]
```
[Вернутся назад](../README.md)


### Найти больше, чем первое совпадение

Для поиска или извлечения шаблона более одного раза можно использовать флаг ```g```

* Мультифлаги записываются подряд(```/search/gi``` - тут 2 флага, ```g``` и ```i```)

```javascript
let twinkleStar = "Twinkle, twinkle, little star";
let starRegex = /twinkle/gi 
let result = twinkleStar.match(starRegex);
```

### Сопоставить что-либо с подстановочным периодом (Willcard Period)

Иногда вы не будете (или не нужно) знать точные символы в ваших шаблонах. Думать обо всех словах, которые соответствуют скажем, слогу ```say``` , займет много времени. К счастью мы можем использовать подстановочный знак ```.```

Подстановочный знак так же называется "точкой" или "периодом". Например, если вы хотите сопоставить "hug", "huh", "hut", и "hum", вы можете использовать регулярное выражение ```/hu./``` - что будет соответствовать всем четырем словам.

```javascript
let humStr = "I'll hum a song";
let hugStr = "Bear hug";
let huRegex = /hu./i;
huRegex.test(humStr); // Returns true
huRegex.test(hugStr); // Returns true
```

### Сопоставить один символ с несколькими возможностями

Вы узнали, как сопоставить литеральные шаблоны ```/literal/``` и подстановочный знак ```/./```. Это крайности регулярных выражений, где один находит точные соответствия, а другой соответствует всему. Есть варианты, которые представляют собой баланс между двумя крайностями.

Вы можете искать литеральные шаблоны с некоторой гибкостью с помощью символьных классов. Символьные классы позволяют определить группу символов, которым вы хотите соответствовать, помещая их в квадратные ```[]``` скобки.

```javascript
let bigStr = "big";
let bagStr = "bag";
let bugStr = "bug";
let bogStr = "bog";
let bgRegex = /b[aiu]g/;
bigStr.match(bgRegex); // Returns ["big"]
bagStr.match(bgRegex); // Returns ["bag"]
bugStr.match(bgRegex); // Returns ["bug"]
bogStr.match(bgRegex); // Returns null
```

### Сопоставление букв алфавита

Внутри набора символов можно определить диапазон символов для сопоставления с помощью символа дефиса ```-```.

Например для сопоставление строчных букв от ```a``` до ```e``` вы можете использовать ```/[a-e]/```.

```javascript
let catStr = "cat";
let batStr = "bat";
let matStr = "mat";
let bgRegex = /[a-e]at/;
catStr.match(bgRegex); // Returns ["cat"]
batStr.match(bgRegex); // Returns ["bat"]
matStr.match(bgRegex); // Returns null
```

### Сопоставление цифр и буква алфавита

Использование дефиса ```-``` для сопоставления диапазона символов не ограничивается буквами. Он так же работает, что бы сопоставить ряд чисел.

Например, ```/[0-5]/``` соответствует любому числу между 0 и 5, включая 0 и 5.

Кроме того, можно объеденить ряд букв и цифр в одном наборе символов.

```javascript
let jennyStr = "Jenny8675309";
let myRegex = /[a-z0-9]/ig;
// matches all letters and numbers in jennyStr
jennyStr.match(myRegex);
```

### Черный список для отдельных символов(отрицательный набор символов)

Всё это время вы создавали наборы символов, которые вы хотите сопоставить, но вы так же можете создать наборы символов, которые вы не хотите сопостовлять. Эти типы наборов символов называются *отрицательными наборами символов*.

Для создания отрицательного набора символов, поместите символ каретки ```(^)``` после открывающей скобки но перед символами, которые вы не хотите сопоставлять.

Например ```/[^aeiou]/``` соответствует всем символам, которые не являются гласными.

* Обратите внимание что такие символы, как ```.```, ```!```, ```[```, ```@```, ```/``` и пробел - всё ещё учитываются. Отрицательный набор гласных символов исключает только гласные символы.

```javascript
let quoteSample = "3 blind mice.";
let myRegex = /[^aeiou0-9]/gi; 
let result = quoteSample.match(myRegex)
```

### Сопоставление символов, которые встречаются один или несколько раз

Иногда вам нужно будет сопоставить символ(или группу символов), который появляется один или несколько раз **подряд**. Это означает, что это происходит по крайней мере один раз и может быть повторено.

Вы можете использовать символ ```+```, что бы проверить, так ли это.

* Помните, что символ или последовательность символов должны идти последовательно, друг за другом.

Например, ```/a+/g``` найдет одно совпадение в ```"abc"``` и вернет ```["a"]```. Из-за ```+```, он так же найдет одно совпадение в ```"aabc"``` и вернет ```["aa"]```.

* Если бы он вместо этого проверял строку ```"abab"```, он нашел бы два совпадения и вернул ```["a", "a"]```, потому что символы ```"a"``` не находятся друг за другом - между ними есть ```"b"```.

```javascript
let difficultSpelling = "Mississippi";
let myRegex = /s+/ig; // Change this line
let result = difficultSpelling.match(myRegex);
```

### Сопоставление символов, которые встречаются ноль или более раз

Существует так же опция, которая соответствует символам, которые встречаются ноль или более раз.

Символ для этого - звездочка ```*```.

В принципе это почти то же самое, что и предыдущее сопоставление, только тут больше свободы для поиска соответствий. Например в примере ниже мы сделали букву ```о``` не обязательной для условий сопоставления. А вот буква ```g``` - обязательна, если ее не будет в проверямой строке, но будет ```o``` , тест выдаст ```null```.

```javascript
let soccerWord = "gooooooooal!";
let gPhrase = "gut feeling";
let oPhrase = "over the moon";
let goRegex = /go*/;
soccerWord.match(goRegex); // Returns ["goooooooo"]
gPhrase.match(goRegex); // Returns ["g"]
oPhrase.match(goRegex); // Returns null
```

### Поиск символов с ленивым соответствием

В регулярных выражениях жадное ```greedy``` совпадение находит максимально длинную часть строки, которая соответствует шаблону регулярного выражения, и возвращает ее как совпадение. В противовес ему есть ленивое ```lazy``` совпадение, которое находит наименьшую возможную часть строки, удовлетворяющую шаблону регулярного выражения.

Вы можете применить регулярное выражение ```/t[a-z]*i/``` к строке ```"titanic"```. Это регулярное выражение в основном является шаблоном, который начинается с ```"t"```, заканчивается на ```"i"``` и имеет несколько букв между ними.

Регулярные выражения по умолчанию являются жадными, поэтому совпадение вернет ```["titani"]```. Он находит самую большую подстроку, которая может соответствовать шаблону.

Тем не менее, вы можете использовать ```?``` символ, чтобы изменить его на ленивое соответствие. ```"titanic"``` соответствуя скорректированному регулярному выражению ```/t[a-z]*?i/``` вернет ```["ti"]```.

* Синтаксического анализа HTML с регулярными выражениями следует избегать, но сопоставление шаблона HTML-строки с регулярными выражениями полностью нормально.

```javascript
let text = "<h1>Winter is coming</h1>";
let myRegex = /<*.h1>?/g; // Change this line
let result = text.match(myRegex); // return ["<h1>,</h1>"]
```

### Сопоставление начальных строковых шаблонов

Предыдущие задачи показали, что регулярные выражения можно использовать для поиска нескольких совпадений. Они также используются для поиска шаблонов в определенных позициях в строках.

В более ранней задаче вы использовали символ каретки ```(^)``` внутри набора символов для создания отрицательного набора символов, например - ```[^things]```. За пределами набора символов каретка используется для поиска шаблонов в начале строк.

```javascript
let firstString = "Ricky is first and can be found.";
let firstRegex = /^Ricky/;
firstRegex.test(firstString);
// Returns true
let notFirst = "You can't find Ricky now.";
firstRegex.test(notFirst);
// Returns false
```

### Сопоставление конечных строковых шаблонов

Существует также способ поиска шаблонов в конце строк.

Вы можете искать конец строки, используя символ доллара ```$``` в конце регулярного выражения.

```javascript
let theEnding = "This is a never ending story";
let storyRegex = /story$/;
storyRegex.test(theEnding);
// Returns true
let noEnding = "Sometimes a story will have to end";
storyRegex.test(noEnding);
// Returns false
```

### Сопоставление всех букв и цифр

Используя символьный класс, вы смогли найти все буквы алфавита с помощью ```[a-z]```. Этот тип символьных классов достаточно распространен, так что для него есть отдельный ярлык, хотя он так же включает в себя несколько дополнительных символов.

Ближайший символьный класс в javascript, что бы соответствовать алфавиту это ```\w```. Этот ярлык равен ```[A-Za-z0-9_]```. Этот символьный класс соответствует верхним и нижним буквам плюс цифры. Обратите внимание, что этот символьный класс так же включает символ подчеркивания ```(_)```.

```javascript
let longHand = /[A-Za-z0-9_]+/;
let shortHand = /\w+/;
let numbers = "42";
let varNames = "important_var";
longHand.test(numbers); // Returns true
shortHand.test(numbers); // Returns true
longHand.test(varNames); // Returns true
shortHand.test(varNames); // Returns true
```

* Эти символьные классы быстрого доступа также известны как классы сокращенных символов.


### Сопоставление всего кроме букв и цифр

Естественный паттерн, который вы, возможно, захотите найти - это противоположность буквенно-цифровому.

Вы можете искать противоположность ```\w``` с ```\W```. Обратите внимание, что противоположный шаблон использует заглавную букву. Этот ярлык соответствует ```[^A-Za-z0-9_]```.

```javascript
let shortHand = /\W/;
let numbers = "42%";
let sentence = "Coding!";
numbers.match(shortHand); // Returns ["%"]
sentence.match(shortHand); // Returns ["!"]
```

### Сопоставление всех чисел

Другой распространенный паттерн ищет только цифры.

Ярлык для поиска цифровых символов это ```\d```, с маленькой ```d```. Это равно символьному классу ```[0-9]```, который ищет один символ любого числа от нуля до девяти.

```javascript
let movieName = "2001: A Space Odyssey";
let numRegex = /\d/g;
let result = movieName.match(numRegex).length;
```

### Сопоставление всех не чисел

Вы так же можете искать не цифры, используя аналогичный ярлык, который использует заглавную ```D``` вместо ```d```.

Ярлык для поиска нецифровых символов это ```\D```, что соответствует символьному классу ```[^0-9]```, который ищет один символ, который не является числом между нулем и девятью.

```javascript
let movieName = "2001: A Space Odyssey";
let noNumRegex = /\D/g;
let result = movieName.match(noNumRegex).length;
```

### Совпадение пробелов

Вы также можете сопоставить пробелы или пробелы между буквами.

Вы можете искать пробелы с помощью ярлыка```\s```, который является строчным s. Этот шаблон соответствует не только пробелам, но и возврату каретки, табуляции, подаче формы и символам новой строки. Вы можете думать о нем, как о подобном символьном классе ```[ \r\t\f\n\v]```.

```javascript
let whiteSpace = "Whitespace. Whitespace everywhere!"
let spaceRegex = /\s/g;
whiteSpace.match(spaceRegex);
// Returns [" ", " "]
```

### Сопоставление символов без пробелов

Поиск не пробелов с помощью ```\S```, которая является заглавной ```S```. Соответствует ```[^ \r\t\f\n\v]```.

```javascript
let whiteSpace = "Whitespace. Whitespace everywhere!"
let nonSpaceRegex = /\S/g;
whiteSpace.match(nonSpaceRegex).length; // Returns 32
```

### Установка верхнего и нижнего числа совпадений

Помните, что знак плюс ```+``` используется для поиска одного или нескольких символов, а звездочка ```*``` - для поиска нуля или нескольких символов. Это удобно, но порой вы хотите, что бы поиск соответствовал определенному диапазону шаблонов.

Вы можете указать нижнее и верхнее число шаблонов с помощью спецификаторов количества. Спецификатор количества используется с фигурными скобками ```({and})```. Вы ставите два числа между фигурными скобами для нижнего и верхнего числа шаблонов.

Например, чтобы соответствовать только букве ```"a"```, появляющейся между 3 и 5 раз в строке ```"ah"```, ваше регулярное выражение будет ```/a{3,5}h/```.

```javascript
let A4 = "aaaah";
let A2 = "aah";
let multipleA = /a{3,5}h/;
multipleA.test(A4); // Returns true
multipleA.test(A2); // Returns false
```

### Установка только нижнего числа совпадений

Иногда требуется указать только нижнее число шаблонов без верхнего предела.

Чтобы указать только меньшее число шаблонов, оставьте первое число, за которым следует запятая.

Например, чтобы соответствовать только строек ```"hah"``` с буквой ```a```, появляющейся не менее 3 раз, ваше регулярное выражение будет ```/ha{3,}h/```.

```javascript
let A4 = "haaaah";
let A2 = "haah";
let A100 = "h" + "a".repeat(100) + "h";
let multipleA = /ha{3,}h/;
multipleA.test(A4); // Returns true
multipleA.test(A2); // Returns false
multipleA.test(A100); // Returns true
```

### Установка точного количества совпадений

Когда вам требуется определить точное количество совпадений, достаточно просто поместить это число между фигурными скобками.

Например, что бы сопоставить только слово ```"hah"``` с буквой ```a``` 3 раза, ваше регулярное выражение будет ```/ha{3}h/```.

```javascript
let A4 = "haaaah";
let A3 = "haaah";
let A100 = "h" + "a".repeat(100) + "h";
let multipleHA = /ha{3}h/;
multipleHA.test(A4); // Returns false
multipleHA.test(A3); // Returns true
multipleHA.test(A100); // Returns false
```

### Проверка всего или ничего

Может случится так, что шаблоны, которые вы хотите найти, могут иметь части, которые могут существовать или не существовать.

Можно указать возможное существование элемента вопросительны знаком ```?```. При это проверяется наличие одного экземпляра элемента, идущего перед ```?```, или его отсутсвие. Проще всего думать об этом символе как о том, что предыдущий элемент является необязательным. Это как кот шредингера - элемент одновременно существует и не существует, определить его фактическое состояние можно только после проверки!

```javascript
let american = "color";
let british = "colour";
let rainbowRegex= /colou?r/;
rainbowRegex.test(american); // Returns true
rainbowRegex.test(british); // Returns true
```

### Положительный и отрицательный предпросмотр

Предпросмотры это шаблоны, которые говорят javascript заглянуть вперед в вашу строку, что бы проверить наличие шаблонов дальше. Это может быть полезно, если вы хотите найти несколько шаблонов в одной строке.

Существует два вида заглядывания вперед: положительного ```positive``` и отрицательного ```negative``` предпросмотра.

Положительный предпросмотр будет смотреть, чтобы убедиться, что элемент в шаблоне поиска есть, но на самом деле не будет соответствовать ему. Положительный предпросмотр выглядит как ```(?=...)``` где ```...``` является необходмой частью, которая не соответствует.

С другой стороны, отрицательный предпросмотр будет смотреть, что бы убедится, что элемент в шаблоне поиска не существует. Отрицательный предпросмотр выглядит так ```(?!...)``` где ```...``` это образец того, чего вы не хотите увидеть там. Остальная часть шаблона возвращается, если отрицательная часть предпросмотра отсутствует.

```javascript
let quit = "qu";
let noquit = "qt";
let quRegex= /q(?=u)/;
let qRegex = /q(?!u)/;
quit.match(quRegex); // Returns ["q"]
noquit.match(qRegex); // Returns ["q"]
```

Более практичным использованием предпросмотра является проверка двух или более шаблонов в одной строке. Вот простая проверка пароля, которая ищет между 3 и 6 символами и по крайней мере одним числом:

```javascript
let password = "abc123";
let checkPass = /(?=\w{3,6})(?=\D*\d)/;
checkPass.test(password); // Returns true
```

### Проверка на смешанную группировку символов

Иногда мы хотим проверить наличие групп символов с помощью регулярного выражения и для этого используем круглые скобки ```()```.

Если вы хотите найти ```Penguin``` или ```Pumpkin``` в строке, вы можете использовать следующее регулярное выражение: ```/P(engu|umpk)in/g```

Затем проверьте, находятся ли нужные группы строк в тестовой строке, используя метод ```test()```.

```javascript
let testStr = "Pumpkin";
let testRegex = /P(engu|umpk)in/;
testRegex.test(testStr);
// Returns true
```

### Повторное использование шаблонов с помощью класса захвата

Некоторые шаблоны, которые вы ищите, будут встречаться несколько раз в строке. Бесполезно вручную повторять это регулярное выражение. Есть лучший способ указать, когда у вас есть несколько повторяющихся подстрок в строке.

Круглые скобки ```()``` используются для поиска повторяющихся подстрок. Вы помещаете регулярное выражение шаблона, которое будет повторятся между скобками.

Чтобы указать, где будет отображаться эта строка повтора, используйте обратную косую черту ```\```,  затем число. Это число начинается с 1 и увеличивается с каждым дополнительным классом захвата, который вы используете. Примером может быть ```1```, чтобы соответствовать первому классу.

Приведенный ниже пример соответствует любому слову, которое встречается дважды через пробел:

```javascript
let repeatStr = "regex regex";
let repeatRegex = /(\w+)\s\1/;
repeatRegex.test(repeatStr); // Returns true
repeatStr.match(repeatRegex); // Returns ["regex regex", "regex"]
```

Стоит еще более подробнее разобрать эту тему на примере задачки ниже. Нужно использовать класс захвата в ```reRegex``` для сопоставления чисел, которые повторяются только три раза в строке, каждый из которых разделен пробелом.

```javascript
let repeatNum = "42 42 42";
let reRegex = /^(\d+)\s\1\s\1$/;
let result = reRegex.test(repeatNum);
```

### Использование класса захвата для поиска и замены

Поиск полезен. Однако вы можете сделать поиск еще более мощным, когда он также изменяет (или заменяет) соответствующий текст.

Вы можете искать и заменять текст в строке с помощью ```.replace()```. 
* Первый параметр для ```.raplace()``` это шаблон регулярного выражения для поиска.
* Второй параметро - это строка для замены совпадений или функция для выполнения каких либо действий.

```javascript
let wrongText = "The sky is silver.";
let silverRegex = /silver/;
wrongText.replace(silverRegex, "blue");
// Returns "The sky is blue."
```

Вы так же можете получить доступ к классам захвата в строке замены, используя знак доллара ```$```.

```javascript
let str = "one two three";
let fixRegex = /(\w+)\s(\w+)\s(\w+)/;
let replaceText = "$3 $2 $1"; 
let result = str.replace(fixRegex, replaceText);
//return  "three two one" 
```

### Удаление пробелов из начала и конца

Бывает так, что пробелы вокруг строк не нужны, но они там всё равно есть. Типичная обработка строк заключается в удалении пробелов в их начале и конце.

```javascript
let hello = "   Hello, World!  ";
let wsRegex = /^\s+(\w+,\s\w+!)\s+$/;
let change = "$1"
let result = hello.replace(wsRegex, change);
```

[Назад](../README.md)



















