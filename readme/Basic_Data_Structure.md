## Основные структуры данных

### Добавление элементов в масств с помощью ```push()``` и ```unshift()```

Методо ```push()``` добавляет элемент в конец массива, а метод ```unshift()``` в начало.

### Удаление элементов из массива с помощью ```pop()``` и ```shift()```

```pop()``` - удаляет элемент из конца массива, а ```shift()``` удаляет элемент из начала.

Ключевое различие от добавляющих методов выше заключается в том, что ни один из методов не принимает параметры, и каждый позволяет изменить массив только один элемент за раз.

УДАЛЯТЬ И ДОБАВЛЯТЬ ЭЛЕМЕНТЫ В КОНЕЦ МАССИВА БЫСТРЕЕ ЧЕМ В НАЧАЛО.

### Удаление элементов с помощью ```splice()```

Итак, мы научили удалять элементы из начала и конца массивов с помощью ```pop()``` и ```shift()```, но что делать, если мы хотим удалить элемент откуда-то из середины? Или удалить сразу несколько элементов? Ну, вот тут-то и появляется функция ```splice()```.

```splice()``` может принимать до 3 параметров, но сейчас мы сосредоточимся на первых 2. Они являются целыми числами, которые представляют индексы или позиции массива, к которому вызывается ```splice()```.

Первый параметр ```splice()``` представляет собой индекс массива, из которого следует начать удаление элементов, а второй параметр указывает количество элементов, подлежащих удалению.

Например:

```javascript
let array = ['today', 'was', 'not', 'so', 'great'];

array.splice(2, 2);
// remove 2 elements beginning with the 3rd element
// array now equals ['today', 'was', 'great']
```

```splice()``` не только изменяет вызываемый массив, но и возвращает новый массив, содержащий значенеи удаленных элементов:

```javascript
let array = ['I', 'am', 'feeling', 'really', 'happy'];

let newArray = array.splice(3, 2);
// newArray equals ['really', 'happy']
```

### Добавление элементов с помощью ```splice()```

Выше мы ведь упоминали, что ```splice()``` может принимать до трех параметром?

Ну, вы можете использовать третий параметр, состоящий из одного или нескольких элементов, чтобы добавить его в массив. Это может быть невероятно полезно для быстрого переключения одного элемента или набора элементов на другой.

```javascript
const numbers = [10, 11, 12, 12, 15];
const startIndex = 3;
const amountToDelete = 1;

numbers.splice(startIndex, amountToDelete, 13, 14);
// the second entry of 12 is removed, and we add 13 and 14 at the same index
console.log(numbers);
// returns [ 10, 11, 12, 13, 14, 15 ]
```

Индекс, с которого начинается удаление элементов (3), число элементов, подлежащих удалению(1), и элементы (13, 14), которые должны быть вставлены в этот же индекс.

Стоит обратить внимание, что после ```amountToDelete``` может быть любое количество элементов, через запятую, каждый из которых вставляется.

### Копирование элементов массива с помощью ```slice()```

Следующий метод, который мы рассмотрим - это ```slice()```. 

```slice()```, вместо того что бы изменять массив, копирует или извлекает заданное количество элементов в новый массив, оставляя вызываемый массив нетронутым.

```slice()``` принимает только 2 параметра - первый является индексом, с которого начинается извлечение, а второй - индексом, с которого извлечение прекращается(извлечение будет происходить до, но не включая элемент с этим индексом).

Например:

```javascript
let weatherConditions = ['rain', 'snow', 'sleet', 'hail', 'clear'];

let todaysWeather = weatherConditions.slice(1, 3);
// todaysWeather equals ['snow', 'sleet'];
// weatherConditions still equals ['rain', 'snow', 'sleet', 'hail', 'clear']
```

### Копирование массива с помощью оператора расширения (spread operator)

В то время как ```slice()``` повзоляет нам выбирать, какие элементы массива копировать, среди нескольких полезных задач новый оператор расширения в ES6 позволяет нам легко копировать все элементы массива, по порядку, с простым и хорошо читаемым синтаксисом. Синтаксис расширения выглядит следующим образом - ```...```

На практике мы можем использовать оператор расширения для копирования массива следующим образом:

```javascript
let thisArray = [true, true, undefined, false, null];
let thatArray = [...thisArray];
// thatArray equals [true, true, undefined, false, null]
// thisArray remains unchanged, and is identical to thatArray
```

### Объединение массивов с помощью оператора расширения (spread operator)

Еще одним огромным приемущством оператора расширения, является возможность комбинировать массивы, или вставлять все элементы одного массива в другой, при любом индексе. С более традиционным синтаксисом мы можем объединять массивы, но это позволяет нам объединять массивы только в конце одного и в начале другог.

Синтаксис расширения делает следующую операцию чрезвычайно простой:

```javascript
let thisArray = ['sage', 'rosemary', 'parsley', 'thyme'];

let thatArray = ['basil', 'cilantro', ...thisArray, 'coriander'];
// thatArray now equals ['basil', 'cilantro', 'sage', 'rosemary', 'parsley', 'thyme', 'coriander']
```

Используя синтаксис расширения, мы только что достигли операции, которая была бы более сложной и более подробной, если бы мы использовали традиционные методы.


### Проверка наличия элемента с ```indexOf()```

Поскольку массивы могут быть изменены или мутированы в любое время, нет никакой гарантии в том, где конкретный фрагмент данных будет находится в данном массиве, или что этот элемент до сих пор существует. 

К счастью javascript предоставляет нам еще один встроенный метод ```indexOf()```, который позволяет быстро и легко проверить наличие элемента в массиве. ```indexOf()``` принимает элемент в качестве параметра и при вызове возвращает позицию или индекс этого элемента, или -1, если элемента в массиве нет.

```javascript
let fruits = ['apples', 'pears', 'oranges', 'peaches', 'pears'];

fruits.indexOf('dates'); // returns -1
fruits.indexOf('oranges'); // returns 2
fruits.indexOf('pears'); // returns 1, the first index at which the element exists
```

Данный метод невероятно полезен для быстрой проверки наличия элемента в массиве.

### Перебор элеметнов массива, используя цикл ```for```

При работе с массивами очень удобного иметь возможность перебирать каждый элемент, чтобы найти один или несколько элементов, которые нам могут понадобиться, или манипулировать массивом, на основе которого элементы данных будут соответствовать определенному набору критериев.

JavaScript предлагает несколько встроенных методов, каждый из которых перебирает массивы различными способами для достижения различных результатов (такие как ```every()```, ```forEach()```, ```map()``` и другие), однако метод, который является наиболее гибким и пделагает нам наибольшее количество контроля, является простым циклом ```for```.

```javascript
function greaterThanTen(arr) {
  let newArr = [];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > 10) {
      newArr.push(arr[i]);
    }
  }
  return newArr;
}

greaterThanTen([2, 12, 8, 14, 80, 0, 1]);
// returns [12, 14, 80]
```

Используя цикл ```for```, эта функция выполяет итерацию и обращается к каждому элементу массива, а также подтвергает его простой проверке, которую мы создали. Таким образом, мы легко и программно определили, какие элементы данных больше 10, и возвратили их в новый массив.


### Создание сложных многомерных массивов

Одной из наиболее мощных особенностей при рассмотрении массивов как структур данных являетто то, что массивы могут содержать или даже полностью состоять из других массивов. В прошлых задачах мы уже видели массивы, которые содержат внутри себя массивы - но это были довольно простые примеры.

Однако массивы могут содержать бесконечную глубину массивов, которые могут содержать другие массивы, каждый со своим произвольным уровнем глубины, и так далее. Таким образом, массив очень быстро превратится в очень сложную структуру данных, известную как многомерный или вложенный массив.

Рассмотрим следующий пример:

```javascript
let nestedArray = [ // top, or first level - the outer most array
  ['deep'], // an array within an array, 2 levels of depth
  [
    ['deeper'], ['deeper'] // 2 arrays nested 3 levels deep
  ],
  [
    [
      ['deepest'], ['deepest'] // 2 arrays nested 4 levels deep
    ],
    [
      [
        ['deepest-est?'] // an array nested 5 levels deep
      ]
    ]
  ]
];
```

Хотя этот пример может показатся запутанным, этот довольно простой пример при работе с большими объемами данных. Мы всё еще можем очень легко получить доступ к самым глубоким уровням массива при помощи скобочной нотации:

```javascript
console.log(nestedArray[2][1][0][0][0]);
// logs: deepest-est?
```

И теперь, когда мы знаем, где находиться этот фрамент данных, мы можем сбросить, если нам нужно:

```javascript
nestedArray[2][1][0][0][0] = 'deeper still';

console.log(nestedArray[2][1][0][0][0]);
// now logs: deeper still
```


### Добавление пар Ключ-Значение в объекты javascript

В самом общем виде объекты - это просто наборы пар Ключ-Значение. Другими словами, они представляют собой фрагменты данных (значений), сопоставленные с уникальными идентификаторами, называемыми свойствами (ключами).

Взглянем на один пример:

```javascript
const tekkenCharacter = {
  player: 'Hwoarang',
  fightingStyle: 'Tae Kwon Doe',
  human: true
};
```

Приведенный выше код определяет объект пресонажа видеоигры Tekken, называемый ```tekkenCharacter```. Он имеет три свойства, каждое из которых соотвествует определенному значению.

Если вы хотите добавить дополнительное свойство, например ```origin```, это можно сделать, присвоив объекту ```origin```:

```javascript
tekkenCharacter.origin = 'South Korea';
```

При это используется точечная нотация. Если мы посмотрим на объект ```tekkenCharacter```, то теперь он будет включать в себя свойство ```origin```. У Хворанга так же были ярко-оранжевые волосы. Мы можем добавить это свойство с помощью скобочной нотации, выполнив следующие действия:

```javascript
tekkenCharacter['hair color'] = 'dyed orange';
```

Скобочная нотация необходима, если в вашем свойстве есть пробел или если вы хотите использовать переменную для имени свойства. В приведенном выше примере свойство заключено в кавычки, чтобы обозначить его как строку.

Без кавычек оно будет оцениватся как переменная, и имя свойства будет соответствовать любому значению переменной. Вот пример с переменной:

```javascript
const eyes = 'eye color';

tekkenCharacter[eyes] = 'brown';
```

После добавления всех примеров объект будет выглядеть следующим образом:

```javascript
{
  player: 'Hwoarang',
  fightingStyle: 'Tae Kwon Doe',
  human: true,
  origin: 'South Korea',
  'hair color': 'dyed orange',
  'eye color': 'brown'
};
```

### Изменения объекта, вложенного в объект.

```javascript
let userActivity = {
  id: 23894201352,
  date: 'January 1, 2017',
  data: {
    totalUsers: 51,
    online: 42
  }
};

userActivity.data.online = 45;

console.log(userActivity); 

/* { id: 23894201352,
   date: 'January 1, 2017',
   data: { totalUsers: 51, online: 45 } } 
*/
```


### Доступ к именам свойств со скобочной нотацией

В первой объектной задаче мы упоминали использование скобочной нотации как способ доступа к значениям свойств с использованием переменных. Например, представьте, что наш объект ```foods``` используется в программе для кассового аппарата супермаркета.

У нас есть некоторая функция, которая устаналивает ```selectFood``` и мы хотим проверить наш объект ```foods``` на наличие этой пищи. Это может выглядеть так:

```javascript
let selectedFood = getCurrentFood(scannedItem);
let inventory = foods[selectedFood];
```

Этот код будет оценивать значение, хранящееся в переменной ```selectedFood``` и возвращать значение этого ключа в объект ```foods``` или возврашать ```undefined```.

Скобочная нотация очень полезна, потому что иногда свойства объекта не известны до времени выполнения, или нам нужно получить к ним доступ более динамическим способом.

```javascript
let foods = {
  apples: 25,
  oranges: 32,
  plums: 28,
  bananas: 13,
  grapes: 35,
  strawberries: 27
};

function checkInventory(scannedItem) {
  // Only change code below this line
  return foods[scannedItem];
  // Only change code above this line
}

console.log(checkInventory("apples"));
```

### Использование ключевого слова ```delete``` для удаления свойств объекта





[Вернутся назад](../README.md)