## JS: Регулярные выражения (regex)

### Использование метода тестирования

Регулярные выражения используются в языках программирования для сопоставления частей строк. Вы создаете шаблоны, которые помогут вам в поисках соответсвий.

Если вы хотите найти слово ```"the"``` в строке ```"The dog chased the cat"```, вы можете использовать следующее ругулярное выражение: ```/the/```. Обратите внимание, что кавычки не требуются.

JavaScript имеет несколько способов применения регулярных выражений. Один из способов использования регулярного выражения, это метод ```.test()```. Этот метод берет регулярное выражение, проверяет его наличие в строке (внутри скобок) и возвращает ```true``` или ```false```.

```javascript
let testStr = "Hello World";
let testRegex = /Hello/;
testRegex.test(testStr);
// returns true
```

### Совпадение литеральных строк

В последнем вызове вы искали слово ```"Hello"```, используя регулярное выражение ```/Hello/```. Это регулярное выражение искало буквальное соотвествие строки ```"Hello"```. Любые другие формы ```"Hello"``` не будут совпадалать. Например, регулярное выражение ```/Hello/``` не будет соответствовать ```"kevin"``` или ```"KEVIN"```.

```javascript
let wrongRegex = /kevin/;
wrongRegex.test(testStr);
// Returns false
```

### Сопоставление литеральных строк с различными возможностями

Используя регулярное выражение тип ```/coding/```, вы можете искать шаблон ```"coding"``` в другой строке.

Это мощный инструмент для поиска отдельных строк, но он ограничен только одним шаблоном. Вы можете искать несколько шаблонов с помощью оператора чередования ```alternation``` или ```OR``` оператора: ```|```.

Этот оператор соответствует шаблонам до или после него. Например, если вы хотите сопоставить ```"yes"``` или ```"no"```, регулярное выражение которое тут нужно это ```/yes|no/```.

Вы также можете искать не только два паттерна. Можно добавить больше шаблонов с большим количеством операторов ```OR```, разделяющих их, например ```/yes|no|maybe/```.


### Игнорирование регистра при сопоставлении

До сих пор вы смотрели на регулярные выражения, чтобы сделать литеральные соотвествия строк. Но иногда вам так же нужно будет сопоставить без учета регистра.

Для этого вы можете применять так называемые флаги. Конкретно в случае, когда вам нужно игнорирование регистра - применяется ```i``` флаг. Вы можете использовать его, добавив к регулярному выражению. Примером использования этого флага является  ```/igmorecase/i```.
```javascript
let myString = "freeCodeCamp";
let fccRegex = /freecodecamp/i;
let result = fccRegex.test(myString);
// return true
```

### Извлечение совпадений

До сих пор вы только проверяли, существует ли шаблон или нет в строке. Вы так же можете извлечь фактические совпадения, которые вы нашли с помощью метода ``` .match()```.
```javascript
"Hello, World!".match(/Hello/);
// Returns ["Hello"]
let ourStr = "Regular expressions";
let ourRegex = /expressions/;
ourStr.match(ourRegex);
// Returns ["expressions"]
```
[Вернутся назад](../README.md)


### Найти больше, чем первое совпадение

Для поиска или извлечения шаблона более одного раза можно использовать флаг ```g```

* Мультифлаги записываются подряд(```/search/gi``` - тут 2 флага, ```g``` и ```i```)

```javascript
let twinkleStar = "Twinkle, twinkle, little star";
let starRegex = /twinkle/gi 
let result = twinkleStar.match(starRegex);
```

### Сопоставить что-либо с подстановочным периодом (Willcard Period)

Иногда вы не будете (или не нужно) знать точные символы в ваших шаблонах. Думать обо всех словах, которые соответствуют скажем, слогу ```say``` , займет много времени. К счастью мы можем использовать подстановочный знак ```.```

Подстановочный знак так же называется "точкой" или "периодом". Например, если вы хотите сопоставить "hug", "huh", "hut", и "hum", вы можете использовать регулярное выражение ```/hu./``` - что будет соответствовать всем четырем словам.

```javascript
let humStr = "I'll hum a song";
let hugStr = "Bear hug";
let huRegex = /hu./i;
huRegex.test(humStr); // Returns true
huRegex.test(hugStr); // Returns true
```

### Сопоставить один символ с несколькими возможностями

Вы узнали, как сопоставить литеральные шаблоны ```/literal/``` и подстановочный знак ```/./```. Это крайности регулярных выражений, где один находит точные соответствия, а другой соответствует всему. Есть варианты, которые представляют собой баланс между двумя крайностями.

Вы можете искать литеральные шаблоны с некоторой гибкостью с помощью символьных классов. Символьные классы позволяют определить группу символов, которым вы хотите соответствовать, помещая их в квадратные ```[]``` скобки.

```javascript
let bigStr = "big";
let bagStr = "bag";
let bugStr = "bug";
let bogStr = "bog";
let bgRegex = /b[aiu]g/;
bigStr.match(bgRegex); // Returns ["big"]
bagStr.match(bgRegex); // Returns ["bag"]
bugStr.match(bgRegex); // Returns ["bug"]
bogStr.match(bgRegex); // Returns null
```

### Сопоставление букв алфавита

Внутри набора символов можно определить диапазон символов для сопоставления с помощью символа дефиса ```-```.

Например для сопоставление строчных букв от ```a``` до ```e``` вы можете использовать ```/[a-e]/```.

```javascript
let catStr = "cat";
let batStr = "bat";
let matStr = "mat";
let bgRegex = /[a-e]at/;
catStr.match(bgRegex); // Returns ["cat"]
batStr.match(bgRegex); // Returns ["bat"]
matStr.match(bgRegex); // Returns null
```

### Сопоставление цифр и буква алфавита

Использование дефиса ```-``` для сопоставления диапазона символов не ограничивается буквами. Он так же работает, что бы сопоставить ряд чисел.

Например, ```/[0-5]/``` соответствует любому числу между 0 и 5, включая 0 и 5.

Кроме того, можно объеденить ряд букв и цифр в одном наборе символов.

```javascript
let jennyStr = "Jenny8675309";
let myRegex = /[a-z0-9]/ig;
// matches all letters and numbers in jennyStr
jennyStr.match(myRegex);
```

### Черный список для отдельных символов(отрицательный набор символов)

Всё это время вы создавали наборы символов, которые вы хотите сопоставить, но вы так же можете создать наборы символов, которые вы не хотите сопостовлять. Эти типы наборов символов называются *отрицательными наборами символов*.

Для создания отрицательного набора символов, поместите символ каретки ```(^)``` после открывающей скобки но перед символами, которые вы не хотите сопоставлять.

Например ```/[^aeiou]/``` соответствует всем символам, которые не являются гласными.

* Обратите внимание что такие символы, как ```.```, ```!```, ```[```, ```@```, ```/``` и пробел - всё ещё учитываются. Отрицательный набор гласных символов исключает только гласные символы.

```javascript
let quoteSample = "3 blind mice.";
let myRegex = /[^aeiou0-9]/gi; 
let result = quoteSample.match(myRegex)
```

### Сопоставление символов, которые встречаются один или несколько раз

Иногда вам нужно будет сопоставить символ(или группу символов), который появляется один или несколько раз **подряд**. Это означает, что это происходит по крайней мере один раз и может быть повторено.

Вы можете использовать символ ```+```, что бы проверить, так ли это.

* Помните, что символ или последовательность символов должны идти последовательно, друг за другом.

Например, ```/+a/g``` найдет одно совпадение в ```"abc"``` и вернет ```["a"]```. Из-за ```+```, он так же найдет одно совпадение в ```"aabc"``` и вернет ```["aa"]```.

* Если бы он вместо этого проверял строку ```"abab"```, он нашел бы два совпадения и вернул ```["a", "a"]```, потому что символы ```"a"``` не находятся друг за другом - между ними есть ```"b"```.

```javascript
let difficultSpelling = "Mississippi";
let myRegex = /s+/ig; // Change this line
let result = difficultSpelling.match(myRegex);
```

### Сопоставление символов, которые встречаются ноль или более раз

Существует так же опция, которая соответствует символам, которые встречаются ноль или более раз.

Символ для этого - звездочка ```*```.

```javascript
let soccerWord = "gooooooooal!";
let gPhrase = "gut feeling";
let oPhrase = "over the moon";
let goRegex = /go*/;
soccerWord.match(goRegex); // Returns ["goooooooo"]
gPhrase.match(goRegex); // Returns ["g"]
oPhrase.match(goRegex); // Returns null
```

### Поиск символов с ленивым соответствием








