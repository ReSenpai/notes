## JS: Регулярные выражения (regex)

### Использование метода тестирования

Регулярные выражения используются в языках программирования для сопоставления частей строк. Вы создаете шаблоны, которые помогут вам в поисках соответсвий.

Если вы хотите найти слово ```"the"``` в строке ```"The dog chased the cat"```, вы можете использовать следующее ругулярное выражение: ```/the/```. Обратите внимание, что кавычки не требуются.

JavaScript имеет несколько способов применения регулярных выражений. Один из способов использования регулярного выражения, это метод ```.test()```. Этот метод берет регулярное выражение, проверяет его наличие в строке (внутри скобок) и возвращает ```true``` или ```false```.

```javascript
let testStr = "Hello World";
let testRegex = /Hello/;
testRegex.test(testStr);
// returns true
```

### Совпадение литеральных строк

В последнем вызове вы искали слово ```"Hello"```, используя регулярное выражение ```/Hello/```. Это регулярное выражение искало буквальное соотвествие строки ```"Hello"```. Любые другие формы ```"Hello"``` не будут совпадалать. Например, регулярное выражение ```/Hello/``` не будет соответствовать ```"kevin"``` или ```"KEVIN"```.

```javascript
let wrongRegex = /kevin/;
wrongRegex.test(testStr);
// Returns false
```

### Сопоставление литеральных строк с различными возможностями

Используя регулярное выражение тип ```/coding/```, вы можете искать шаблон ```"coding"``` в другой строке.

Это мощный инструмент для поиска отдельных строк, но он ограничен только одним шаблоном. Вы можете искать несколько шаблонов с помощью оператора чередования ```alternation``` или ```OR``` оператора: ```|```.

Этот оператор соответствует шаблонам до или после него. Например, если вы хотите сопоставить ```"yes"``` или ```"no"```, регулярное выражение которое тут нужно это ```/yes|no/```.

Вы также можете искать не только два паттерна. Можно добавить больше шаблонов с большим количеством операторов ```OR```, разделяющих их, например ```/yes|no|maybe/```.


### Игнорирование регистра при сопоставлении

До сих пор вы смотрели на регулярные выражения, чтобы сделать литеральные соотвествия строк. Но иногда вам так же нужно будет сопоставить без учета регистра.

Для этого вы можете применять так называемые флаги. Конкретно в случае, когда вам нужно игнорирование регистра - применяется ```i``` флаг. Вы можете использовать его, добавив к регулярному выражению. Примером использования этого флага является  ```/igmorecase/i```.
```javascript
let myString = "freeCodeCamp";
let fccRegex = /freecodecamp/i;
let result = fccRegex.test(myString);
// return true
```

### Извлечение совпадений

До сих пор вы только проверяли, существует ли шаблон или нет в строке. Вы так же можете извлечь фактические совпадения, которые вы нашли с помощью метода ``` .match()```.
```javascript
"Hello, World!".match(/Hello/);
// Returns ["Hello"]
let ourStr = "Regular expressions";
let ourRegex = /expressions/;
ourStr.match(ourRegex);
// Returns ["expressions"]
```
[Вернутся назад](../README.md)


### Найти больше, чем первое совпадение

Для поиска или извлечения шаблона более одного раза можно использовать флаг ```g```

* Мультифлаги записываются подряд(```/search/gi``` - тут 2 флага, ```g``` и ```i```)

```javascript
let twinkleStar = "Twinkle, twinkle, little star";
let starRegex = /twinkle/gi 
let result = twinkleStar.match(starRegex);
```

### Сопоставить что-либо с подстановочным периодом (Willcard Period)

Иногда вы не будете (или не нужно) знать точные символы в ваших шаблонах. Думать обо всех словах, которые соответствуют скажем, слогу ```say``` , займет много времени. К счастью мы можем использовать подстановочный знак ```.```

Подстановочный знак так же называется "точкой" или "периодом". Например, если вы хотите сопоставить "hug", "huh", "hut", и "hum", вы можете использовать регулярное выражение ```/hu./``` - что будет соответствовать всем четырем словам.

```javascript
let humStr = "I'll hum a song";
let hugStr = "Bear hug";
let huRegex = /hu./i;
huRegex.test(humStr); // Returns true
huRegex.test(hugStr); // Returns true
```

### Сопоставить один символ с несколькими возможностями

Вы узнали, как сопоставить литеральные шаблоны ```/literal/``` и подстановочный знак ```/./```. Это крайности регулярных выражений, где один находит точные соответствия, а другой соответствует всему. Есть варианты, которые представляют собой баланс между двумя крайностями.

Вы можете искать литеральные шаблоны с некоторой гибкостью с помощью символьных классов. Символьные классы позволяют определить группу символов, которым вы хотите соответствовать, помещая их в квадратные ```[]``` скобки.

```javascript
let bigStr = "big";
let bagStr = "bag";
let bugStr = "bug";
let bogStr = "bog";
let bgRegex = /b[aiu]g/;
bigStr.match(bgRegex); // Returns ["big"]
bagStr.match(bgRegex); // Returns ["bag"]
bugStr.match(bgRegex); // Returns ["bug"]
bogStr.match(bgRegex); // Returns null
```

### Сопоставление букв алфавита

Внутри набора символов можно определить диапазон символов для сопоставления с помощью символа дефиса ```-```.

Например для сопоставление строчных букв от ```a``` до ```e``` вы можете использовать ```/[a-e]/```.

```javascript
let catStr = "cat";
let batStr = "bat";
let matStr = "mat";
let bgRegex = /[a-e]at/;
catStr.match(bgRegex); // Returns ["cat"]
batStr.match(bgRegex); // Returns ["bat"]
matStr.match(bgRegex); // Returns null
```

### Сопоставление цифр и буква алфавита

Использование дефиса ```-``` для сопоставления диапазона символов не ограничивается буквами. Он так же работает, что бы сопоставить ряд чисел.

Например, ```/[0-5]/``` соответствует любому числу между 0 и 5, включая 0 и 5.

Кроме того, можно объеденить ряд букв и цифр в одном наборе символов.

```javascript
let jennyStr = "Jenny8675309";
let myRegex = /[a-z0-9]/ig;
// matches all letters and numbers in jennyStr
jennyStr.match(myRegex);
```

### Черный список для отдельных символов(отрицательный набор символов)

Всё это время вы создавали наборы символов, которые вы хотите сопоставить, но вы так же можете создать наборы символов, которые вы не хотите сопостовлять. Эти типы наборов символов называются *отрицательными наборами символов*.

Для создания отрицательного набора символов, поместите символ каретки ```(^)``` после открывающей скобки но перед символами, которые вы не хотите сопоставлять.

Например ```/[^aeiou]/``` соответствует всем символам, которые не являются гласными.

* Обратите внимание что такие символы, как ```.```, ```!```, ```[```, ```@```, ```/``` и пробел - всё ещё учитываются. Отрицательный набор гласных символов исключает только гласные символы.

```javascript
let quoteSample = "3 blind mice.";
let myRegex = /[^aeiou0-9]/gi; 
let result = quoteSample.match(myRegex)
```

### Сопоставление символов, которые встречаются один или несколько раз

Иногда вам нужно будет сопоставить символ(или группу символов), который появляется один или несколько раз **подряд**. Это означает, что это происходит по крайней мере один раз и может быть повторено.

Вы можете использовать символ ```+```, что бы проверить, так ли это.

* Помните, что символ или последовательность символов должны идти последовательно, друг за другом.

Например, ```/a+/g``` найдет одно совпадение в ```"abc"``` и вернет ```["a"]```. Из-за ```+```, он так же найдет одно совпадение в ```"aabc"``` и вернет ```["aa"]```.

* Если бы он вместо этого проверял строку ```"abab"```, он нашел бы два совпадения и вернул ```["a", "a"]```, потому что символы ```"a"``` не находятся друг за другом - между ними есть ```"b"```.

```javascript
let difficultSpelling = "Mississippi";
let myRegex = /s+/ig; // Change this line
let result = difficultSpelling.match(myRegex);
```

### Сопоставление символов, которые встречаются ноль или более раз

Существует так же опция, которая соответствует символам, которые встречаются ноль или более раз.

Символ для этого - звездочка ```*```.

В принципе это почти то же самое, что и предыдущее сопоставление, только тут больше свободы для поиска соответствий. Например в примере ниже мы сделали букву ```о``` не обязательной для условий сопоставления. А вот буква ```g``` - обязательна, если ее не будет в проверямой строке, но будет ```o``` , тест выдаст ```null```.

```javascript
let soccerWord = "gooooooooal!";
let gPhrase = "gut feeling";
let oPhrase = "over the moon";
let goRegex = /go*/;
soccerWord.match(goRegex); // Returns ["goooooooo"]
gPhrase.match(goRegex); // Returns ["g"]
oPhrase.match(goRegex); // Returns null
```

### Поиск символов с ленивым соответствием

В регулярных выражениях жадное ```greedy``` совпадение находит максимально длинную часть строки, которая соответствует шаблону регулярного выражения, и возвращает ее как совпадение. В противовес ему есть ленивое ```lazy``` совпадение, которое находит наименьшую возможную часть строки, удовлетворяющую шаблону регулярного выражения.

Вы можете применить регулярное выражение ```/t[a-z]*i/``` к строке ```"titanic"```. Это регулярное выражение в основном является шаблоном, который начинается с ```"t"```, заканчивается на ```"i"``` и имеет несколько букв между ними.

Регулярные выражения по умолчанию являются жадными, поэтому совпадение вернет ```["titani"]```. Он находит самую большую подстроку, которая может соответствовать шаблону.

Тем не менее, вы можете использовать ```?``` символ, чтобы изменить его на ленивое соответствие. ```"titanic"``` соответствуя скорректированному регулярному выражению ```/t[a-z]*?i/``` вернет ```["ti"]```.

* Синтаксического анализа HTML с регулярными выражениями следует избегать, но сопоставление шаблона HTML-строки с регулярными выражениями полностью нормально.

```javascript
let text = "<h1>Winter is coming</h1>";
let myRegex = /<*.h1>?/g; // Change this line
let result = text.match(myRegex); // return ["<h1>,</h1>"]
```

### Сопоставление начальных строковых шаблонов

Предыдущие задачи показали, что регулярные выражения можно использовать для поиска нескольких совпадений. Они также используются для поиска шаблонов в определенных позициях в строках.

В более ранней задаче вы использовали символ каретки ```(^)``` внутри набора символов для создания отрицательного набора символов, например - ```[^things]```. За пределами набора символов каретка используется для поиска шаблонов в начале строк.

```javascript
let firstString = "Ricky is first and can be found.";
let firstRegex = /^Ricky/;
firstRegex.test(firstString);
// Returns true
let notFirst = "You can't find Ricky now.";
firstRegex.test(notFirst);
// Returns false
```

### Сопоставление конечных строковых шаблонов

Существует также способ поиска шаблонов в конце строк.

Вы можете искать конец строки, используя символ доллара ```$``` в конце регулярного выражения.

```javascript
let theEnding = "This is a never ending story";
let storyRegex = /story$/;
storyRegex.test(theEnding);
// Returns true
let noEnding = "Sometimes a story will have to end";
storyRegex.test(noEnding);
// Returns false
```

### Сопоставление всех букв и цифр











