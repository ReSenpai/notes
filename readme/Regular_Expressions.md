## JS: Регулярные выражения (regex)

### Использование метода тестирования

Регулярные выражения используются в языках программирования для сопоставления частей строк. Вы создаете шаблоны, которые помогут вам в поисках соответсвий.

Если вы хотите найти слово ```"the"``` в строке ```"The dog chased the cat"```, вы можете использовать следующее ругулярное выражение: ```/the/```. Обратите внимание, что кавычки не требуются.

JavaScript имеет несколько способов применения регулярных выражений. Один из способов использования регулярного выражения, это метод ```.test()```. Этот метод берет регулярное выражение, проверяет его наличие в строке (внутри скобок) и возвращает ```true``` или ```false```.

```javascript
let testStr = "Hello World";
let testRegex = /Hello/;
testRegex.test(testStr);
// returns true
```

### Совпадение литеральных строк

В последнем вызове вы искали слово ```"Hello"```, используя регулярное выражение ```/Hello/```. Это регулярное выражение искало буквальное соотвествие строки ```"Hello"```. Любые другие формы ```"Hello"``` не будут совпадалать. Например, регулярное выражение ```/Hello/``` не будет соответствовать ```"kevin"``` или ```"KEVIN"```.

```javascript
let wrongRegex = /kevin/;
wrongRegex.test(testStr);
// Returns false
```

### Сопоставление литеральных строк с различными возможностями

Используя регулярное выражение тип ```/coding/```, вы можете искать шаблон ```"coding"``` в другой строке.

Это мощный инструмент для поиска отдельных строк, но он ограничен только одним шаблоном. Вы можете искать несколько шаблонов с помощью оператора чередования ```alternation``` или ```OR``` оператора: ```|```.

Этот оператор соответствует шаблонам до или после него. Например, если вы хотите сопоставить ```"yes"``` или ```"no"```, регулярное выражение которое тут нужно это ```/yes|no/```.

Вы также можете искать не только два паттерна. Можно добавить больше шаблонов с большим количеством операторов ```OR```, разделяющих их, например ```/yes|no|maybe/```.


### Игнорирование регистра при сопоставлении

До сих пор вы смотрели на регулярные выражения, чтобы сделать литеральные соотвествия строк. Но иногда вам так же нужно будет сопоставить без учета регистра.

Для этого вы можете применять так называемые флаги. Конкретно в случае, когда вам нужно игнорирование регистра - применяется ```i``` флаг. Вы можете использовать его, добавив к регулярному выражению. Примером использования этого флага является  ```/igmorecase/i```.
```javascript
let myString = "freeCodeCamp";
let fccRegex = /freecodecamp/i;
let result = fccRegex.test(myString);
// return true
```

### Извлечение совпадений

До сих пор вы только проверяли, существует ли шаблон или нет в строке. Вы так же можете извлечь фактические совпадения, которые вы нашли с помощью метода ``` .match()```.
```javascript
"Hello, World!".match(/Hello/);
// Returns ["Hello"]
let ourStr = "Regular expressions";
let ourRegex = /expressions/;
ourStr.match(ourRegex);
// Returns ["expressions"]
```
[Вернутся назад](../README.md)


### Найти больше, чем первое совпадение

Для поиска или извлечения шаблона более одного раза можно использовать флаг ```g```

* Мультифлаги записываются подряд(```/search/gi``` - тут 2 флага, ```g``` и ```i```)

```javascript
let twinkleStar = "Twinkle, twinkle, little star";
let starRegex = /twinkle/gi 
let result = twinkleStar.match(starRegex);
```

### Сопоставить что-либо с подстановочным периодом (Willcard Period)

Иногда вы не будете (или не нужно) знать точные символы в ваших шаблонах. Думать обо всех словах, которые соответствуют скажем, слогу ```say``` , займет много времени. К счастью мы можем использовать подстановочный знак ```.```

Подстановочный знак так же называется "точкой" или "периодом". Например, если вы хотите сопоставить "hug", "huh", "hut", и "hum", вы можете использовать регулярное выражение ```/hu./``` - что будет соответствовать всем четырем словам.

```javascript
let humStr = "I'll hum a song";
let hugStr = "Bear hug";
let huRegex = /hu./i;
huRegex.test(humStr); // Returns true
huRegex.test(hugStr); // Returns true
```

### Сопоставить один символ с несколькими возможностями

Вы узнали, как сопоставить литеральные шаблоны ```/literal/``` и подстановочный знак ```/./```. Это крайности регулярных выражений, где один находит точные соответствия, а другой соответствует всему. Есть варианты, которые представляют собой баланс между двумя крайностями.

Вы можете искать литеральные шаблоны с некоторой гибкостью с помощью символьных классов. Символьные классы позволяют определить группу символов, которым вы хотите соответствовать, помещая их в квадратные ```[dfv]``` скобки.

```javascript
let bigStr = "big";
let bagStr = "bag";
let bugStr = "bug";
let bogStr = "bog";
let bgRegex = /b[aiu]g/;
bigStr.match(bgRegex); // Returns ["big"]
bagStr.match(bgRegex); // Returns ["bag"]
bugStr.match(bgRegex); // Returns ["bug"]
bogStr.match(bgRegex); // Returns null
```

### Совпадение букв алфавита

Внутри набора символов можно определить диапазон символов для сопоставления с помощью символа дефиса ```-```.

Например для сопоставление строчных букв от ```a``` до ```e``` вы можете использовать ```[a-e]```.

```javascript
let catStr = "cat";
let batStr = "bat";
let matStr = "mat";
let bgRegex = /[a-e]at/;
catStr.match(bgRegex); // Returns ["cat"]
batStr.match(bgRegex); // Returns ["bat"]
matStr.match(bgRegex); // Returns null
```

### Сопоставление цифр и буква алфавита





