## Отладка

### Введение

Отладка является ценным и (к сожалению) необходимым инструментом для программистов.Она следует за этапом тестирования, проверяя, работает ли ваш код так, как задумано, и обнаруживает если это не так.

Отладка - это процесс поиска именн того, что не работает, и его исправления. Эти проблемы, как правило, бывают в трех формах:

1. Синтаксические ошибки, препятствующие запуску программы ```syntax errors```
2. Ошибки времени выполнения, когда код не выполняется или имеет непредвиденное поведение ```runtime errors```
3. Смысловые или логические ошибки, когда код не делает то, что должен делать ```semantic (or logical) errors```

Современные редакторы кода (и опыт) могут помочь выявить синтаксические ошибки.Семантические и временные ошибки найти сложнее. Они могут привести к сбою программы, заставить ее работать вечно или дать неверный вывод. Думайте об отладке как о попытке понять, почему ваш код ведет себя именно так. Пример синтаксической ```syntax``` ошибки часто обнаруживается редактором кода:

```javascript
funtcion willNotWork( 
  console.log("Yuck");
}
// "function" ключевое слово написано с ошибкой или отсутствует скобка
```

Вот пример ошибки времени выполнения ```runtime```, она часто обнаруживается во время выполнения программы:

```javascript
function loopy() {
  while(true) {
    console.log("Hello, world!");
  }
}
// Вызов loopy запускает бесконечный цикл, который может привести к сбою вашего браузера
```

Пример семантической ошибки ```semantic (or logical)```, часто обнаруживается посте тестирования вывода кода:

```javascript
function calcAreaOfRect(w, h) {
  return w + h; // This should be w * h
}
let myRectArea = calcAreaOfRect(2, 3);
// Правильный синтаксис и программа выполняется, но это дает неправильный ответ
```
Отладка помогает разработать (и следовать) пошаговый подход к просмотру кода. Это означает проверку промежуточных значений и типов переменных, чтобы увидеть, являются ли они тем, чем они должны быть. Вы можете начать с простого метода исключения.

Например, если функция ```A``` работает и возращает то, что она должна, то функция ```B``` может иметь проблему. И начните проверять значения в блоке кода с середины, чтобы попытаться сократить пространство поиска в двое. Проблема в первой половине указывает на ошибку в первой половине кода. Если нет, то скорее всего во второй.


### Использование консоли javascript для проверки значения переменной

Chrome и Firefox имеют отличные javascript консоли, также известные как инструменты разработчика для отладки кода javascript.

```console.log()``` метод, который печатает ```"prints"``` вывод того, что находится в его скобках, на консоль, вероятно будет самым полезным инструментом отладки. Размещение его в стратегических точках кода может показать вам промежуточные значения переменных. Наличие контрольных точек для просмотра состояния ваших вычислений во всем коде поможет сузить круг проблем.

Вот пример того, как напечатать "Hello world!" в консоли:

```javascript
console.log('Hello world!');
```

### Очистка консоли

Вы можете использовать ```console.clear()``` для очистки консоли от других тестов. Просто поставьте этот метод после всех тестов, но перед тем, который вам нужен(если он вам нужен).

### Использование typeof для проверки типа переменной

```typeof``` можно использовать для проверки структуры данных или типа переменной. Это полезно при отладке, если вы работаете с несколькими типами данных. Если вы думаете, что добавляете два числа, но одно на самом деел строка, результат может быть неожиданным. Ошибки типа данных могут скрыватся в вычислениях или вызовах функций. Будьте особенно осторожны, когда вы обращаетесь к внешним данным и работаете с ними в виделе JSON.

Вот несколько примеров использования ```typeof```:

```javascript
console.log(typeof ""); // outputs "string"
console.log(typeof 0); // outputs "number"
console.log(typeof []); // outputs "object"
console.log(typeof {}); // outputs "object"
```

JavaScript распознает шесть примитивных(неизменяемых) типов данных: ```Boolean```, ```Null```, ```Undefined```, ```Number```, ```String```, и ```Symbol``` (добавлен в ES6) и один тип для изменяемых элементов: ```Object```. 
* Обратите внимание, что в javascript массивы технически являются типом объекта.

### Имена переменных и функций с ошибками

```console.log()``` и ```typeof``` являются двумя основными способами проверки промежуточных значений и типов вывода программы. Теперь пришло время узнать про общие формы, которые принимают ошибки. Одной из проблем синтаксического уровня, с которой могу столкнутся быстропечатающие разработчики - это скромная орфографическая ошибка.

Перепутанные, отсутствующие или неправильно прописанные символы в имени переменной или функции заставят браузер искать объект, который не существует, и жаловатся в више ошибки ```reference error```. 


### Не замкнутые скобки, кавычки, фигурные или квадратные скобки

Ещё одна синтаксическая ошибка, о которой следует помнить, заключается в том, что все открывающие круглые скобки, квадратные скобки, фигурные скобки и кавычки имеют закрывающую пару. Забывание одной из пары имеет тенденцию происходить, когда вы редактируете существующий код и вставляете элементы с одним из типов пар скобок. Кроме того, будьте осторожны при вложении блоков кода в другие, такие как добавление функции обратного вызова в качестве аргумента к методу.

### Cмешанное использование одинарных и двойных кавычек

JavaScript позволяет использовать как одинарные ```(')```, так и двойные ```(")``` кавычки для объявления строки. Решение о том, какие кавычки использовать, обычно сводится к личным предпочтениям, за некоторыми исключениями.

Наличие двух вариантов кавычек это отлично, когда строка имеет сокращения или другой кусок текста, который находится в кавычках. Просто будьте осторожны, чтобы не закарыть строку слишком рано, что приведет к синтаксической ошибке.

Вот несколько примеров смешивания кавычек:

```javascript
// These are correct:
const grouchoContraction = "I've had a perfectly wonderful evening, but this wasn't it.";
const quoteInString = "Groucho Marx once said 'Quote me as saying I was mis-quoted.'";
// This is incorrect:
const uhOhGroucho = 'I've had a perfectly wonderful evening, but this wasn't it.';
```
Конечно, можно использовать только один стиль кавычек. Кавычки внутри строки можно экранировать с помощью символа обратной косой черты ```(\)```:

```javascript
// Correct use of same quotes:
const allSameQuotes = 'I\'ve had a perfectly wonderful evening, but this wasn\'t it.';
```

### Использование оператора присваивания вместо оператора равенства

Ветвящиеся программы, то есть те, которые делают разные вещи при соблюдении определенных условий, полагаются на операторы ```if```, ```else if``` и ```else``` в JavaScript. Условие иногда принимает форму проверки: "равен ли результат значению ил нет?".

Эта логика выражается так: "если x равно y, то...". Но тут можно вместо сравнения случано присвоить значение с помощью оператора ```=``` присваивания. Это приведет к неожиданному результату в вашей программе.

Вы должны помнить, что оператор присваивания ```(=)``` в javascript присваивает значение имени переменной. А операторы ```==``` и ```===``` проверяют на равенство (тройные ```===``` проверяют на строгое равенство, сравнивая еще и тип данных).

Приведенный ниже код присваивает ```x``` значение 2, которое оценивается как ```true```. Почти каждое значение в javascript само по себе принимает значение ```true```, за исключением так называемых "ложных" значений: ```false```, ```0```, ```""```(пустая строка), ```NaN```, ```undefined``` и ```null```.

```javascript
let x = 1;
let y = 2;
if (x = y) {
  // this code block will run for any value of y (unless y were originally set as a falsy)
} else {
  // this code block is what should run (but won't) in this example
}
```

### Отсутствие открывающих и закрывающих скобок после вызова функции

Когда функция или метод не принимает никаких аргументов, вы можете забыть включить (пустые) открывающие и закрывающие скобки при её вызове. Часто результат вызова функции сохраняется в переменной для другого использования в коде. Эту ошибку можно обнаружить, записав значения переменных (или их типы) в консоль и увидев, что одна из них установлена на ссылку функции, а не на ожидаемое значение, которое возвращает функция.

Это может выглядеть вот так:

```javascript
function myFunction() {
  return "You rock!";
}
let varOne = myFunction; // set to equal a function
let varTwo = myFunction(); // set to equal the string "You rock!"
```

### Аргументы, переданные в неправильном порядке при вызове функции

Продолжая тему о вызове функции, следующая ошибка, на которую следует обратить внимание, - это когда аргументы функции предоставляются в неправильном порядке. 

Если арументы имеют разные типы, такие как функция, ожидающая масив и целое число, это, скорее всего, вызовет ошибку времени выполнения.

А если аргументы одного типа(например, все целые числа), то логика кода не будет иметь смысла и мы получим смысловую(логическую ошибку). Убелитесь в том, чтобы предоставить все необходимые аргументы в правильном порядке, что бы избежать этих проблем.

### Отлавливание по одной ошибке при использовании индексирования(Off By One Errors)

Off By One Errors(иногда называются OBOE) возникают, когда вы пытаетесь настроить таргетинг на определенный индекс строки или массива(срезать(```slice```) или получить доступ к сегменту), или при цикличном переборе их индексов.

Индексация javascript начинается с нуля, а не с еденицы, что означает, что последний индекс всегда на еденицу меньше длины элемента. Если вы попытаетесь получить доступ к индексу, равному длине, программа может выдать ошибку ссылки ```"index out of range"``` или напечатать ```undefined```.

Когда вы используете методы ```string``` или ```array```, которые принимают диапазоны индексов в качестве аргументов, это помогает чтению документации и пониманию, являются ли они включетильными(элемент в данном индексе является частью того, что возвращается) или нет.

Вот несколько примеров ошибок Off By One:

```javascript
let alphabet = "abcdefghijklmnopqrstuvwxyz";
let len = alphabet.length;
for (let i = 0; i <= len; i++) {
  // loops one too many times at the end
  console.log(alphabet[i]);
}
for (let j = 1; j < len; j++) {
  // loops one too few times and misses the first character at index 0
  console.log(alphabet[j]);
}
for (let k = 0; k < len; k++) {
  // Goldilocks approves - this is just right
  console.log(alphabet[k]);
}
```

### Будьте осторожны при повторной инициализации переменных внутри цикла

Иногда необходимо сохранить информацию, увеличение счётчика или повтороно установить переменные в цикле. Потенциальная проблема может возникнуть, если случайно переинициализировать переменную, которую не стоит переинициализировать или наоборот, не переинициализировать переменную, которую надо переинициализировать.

Это особенно опасно, если вы случайно сбросите переменную, используемую для терминального условия, что приведет к бесконечному циклу.

Вывод значения переменных с каждым циклом с помощью ```console.log()``` может выявить ошибки, связанные со сбросом или невозможностью сброса переменной.

Как пример, следуяющая функция должна создавать двумерный массив с "m" строками и "n" столбцами нулей. К сожалению она не производит ожидаемый результат, потому что переменная строки не переинициализируется во внешнем цикле (не возвращается к пустому массиву).

Это можно поправить одной строчкой, я ее закоментил.

```javascript
function zeroArray(m, n) {

    let newArray = [];
    let row = [];
    for (let i = 0; i < m; i++) {
  
      for (let j = 0; j < n; j++) {

        row.push(0);
        console.log(`${row} внутренний`)
    
      }

      newArray.push(row);
      //row = [];
      console.log(`${row} внешний`)
    }
    return newArray;
}
  
let matrix = zeroArray(3, 2);
console.log(matrix);
```




[Вернутся назад](../README.md)
