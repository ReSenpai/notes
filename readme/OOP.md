## Объектно ориентированное программирование

### Создание базоовго JS объекта

Подумайте о вещах, которые люди видят каждый день, таких как автомобили, магазины и птицы. Это все объекты, осязаемые вещи, которые люди могут наблюдать и взаимодействовать.

Каковы некоторые качества этих объектов? У машины есть колеса. Магазины продают товары. У птиц есть крылья.

Эти качества, или свойства, определяют то, что составляет объект. Обратите внимание, что подобные объекты имеют одинаковые свойства, но могут иметь разные значения для этих свойств. Например, все автомобили имеют колеса, но не все автомобили имеют одинаковое количество колес.

Объекты в JS используются для моделирования объектов реального мира, придавая им такие же свойства и поведение, как их реальные аналоги. Вот например использования этих понятий для создания объекта ```duck```:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2
};
```

Этот объект утки имеет два свойства: Имя: "Aflac" и количество ног: 2


### Использование точечной нотации для доступа к свойствам объекта

Выше мы создали объект с разными свойствами. Теперь мы увидим, как получить доступ к значениям этих свойств. Вот например:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2
};
console.log(duck.name);
// This prints "Aflac" to the console
```

Точечная нотация используется на Имя объекта ```duck```, а затем имя свойства ```name```, чтобы получит доступ к значению ```"Aflac"```.


### Создание метода для объекта


Объекты могут иметь специальный тип свойства, назывыемый методом.

Методы - это свойства, которые являются функциями. Это добавляет другое поведение объекту. Вот пример объекта ```duck``` с методом:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {return "The name of this duck is " + duck.name + ".";}
};
duck.sayName();
// Returns "The name of this duck is Aflac."
```

В этом примере добавляется метод ```sayName```, который представляет собой функцию, возвращающую предложение с именем утки. Обратите внимание, что метод получил доступ к свойству ```name``` в операторе ```return``` с помощью ```duck.name```; Следующая задача покажет другой способ сделать это.



### Сделать код многоразовым с помощью ключевого слова ```this```


Пример выше ввел метод для объекта ```duck```. Он использовал точечную нотацию ```duck.name``` для доступа к значению свойства ```name``` в операторе ```return```:

```sayName: function() {return "The name of this duck is " + duck.name + ".";}```

Хоть это и допустимый способ доступа к свойству объекта, здесь есть ловушка. Если имя переменной изменяется, любой код, ссылающийся на исходное имя, так же должен быть обновлен. В коротком определении объекта это не проблема, но если объект имеет много ссылок на его свойства, существует довольно большая вероятность ошибки.

Способ избежать эти проблемы заключается в использовании ключевого слова ```this```:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {return "The name of this duck is " + this.name + ".";}
};
```

```this``` это глубокая тема, и приведенный выше пример является только одним из способов его использования. В текущем контексте это относится к объекту, с которым связан метод: ```duck```. Если имя объекта изменится на ```mallard```, нет необходимости искать все ссылки на ```duck``` в коде. Это делает код более читаемым и многоразовым.


### Определение функции конструктора


Конструкторы - это функции, которые создают новые объекты. Они определяют свойства и поведение, которые будут принадлежать новому объекту. Думайте о них как о плане создания новых объектов.

Вот пример конструктора:

```javascript
function Bird() {
  this.name = "Albert";
  this.color = "blue";
  this.numLegs = 2;
}
```

Этот конструктор определяет объект ```Bird``` со свойствами ```name```, ```color``` и ```numLegs```, равными ```"Albert"```, ```blue``` и ```2``` соотвественно. Конструкторы следуют нескольким соглашениям:

- Конструкторы определяются с заглавным именем, чтобы отличать их от других функций, которые не являются конструкторами.

- Конструкторы используют ключевое слово ```this```, чтобы задавать свойства объекта, который они создают. Внутри конструктора, ```this``` относится к новому объекту, который он создает.

- Конструкторы определяют свойства и поведение, а не возвращают значение, как другие функции.


### Использование конструктора для создания объектов


Вот ```Bird``` конструктор из предыдущей задачи:

```javascript
function Bird() {
  this.name = "Albert";
  this.color  = "blue";
  this.numLegs = 2;
  // "this" inside the constructor always refers to the object being created
}

let blueBird = new Bird();
```

Обратите внимание, что оператор ```new``` используется при вызове конструктора. Это говорит JavaScript-у, что нужно создать новый экземпляр ```Bird``` по названием ```blueBird```. Без оператора ```new```, ```this``` внутри конструктора не указывало бы на вновь созданный объект, давая неожиданные результаты. Теперь ```blueBird``` имеет все свойства, определенные внутри конструктора ```Bird```:

```javascript
blueBird.name; // => Albert
blueBird.color; // => blue
blueBird.numLegs; // => 2
```

Как и любой другой объект, его свойства могут быть получены и изменены:

```javascript
blueBird.name = 'Elvira';
blueBird.name; // => Elvira
```


### Расширение конструкторов для получения аргументов


В ```Bird``` конструкторы из последнего вызова работали хорошо. Однако обратите внимание, что все ```Birds```, созданные с помощью конструктора ```Bird```, автоматически называются Альберт, имеют синий цвет и две ноги. 

Что делать, если вам нужны птицы с разными значениями имени и цвета? Можно изменить свойства каждой птицы вручную, но это будет слишком долго:

```javascript
let swan = new Bird();
swan.name = "Carlos";
swan.color = "white";
```

Предположим, вы пишете программу для отслеживания сотен или даже тысяч различных птиц в вольере. Это займет слишком много времени, чтобы создать всех птиц, а затем изменить свойства на разные значения для каждой из них. 

Чтобы легче создавать различные объекты ```Bird```, вы можете заставить свой конструктор  ```Bird``` принимать параметры:

```javascript
function Bird(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}
```

Затем передайте значения в качестве аргументов для определения каждой уникальной птицы в конструктор ```Bird```: ```let cardinal = new Bird("Bruce", "red");``` Это дает новый экземпляр ```Bird``` со свойствами ```name``` и ```color```, установленными в ```"Bruce"``` и ```"red"``` соответственно. Свойство ```numLegs``` по прежнему имеет значение 2.

```cardinal``` обладает такими свойствами:

```javascript
cardinal.name // => Bruce
cardinal.color // => red
cardinal.numLegs // => 2
```

Такой конструктор является более гибким. Теперь можно определить свойства для каждого экземпляра ```Bird``` во время его создания, что является одним из полезнейших приемуществ использования конструкторов в JavaScript. Они группируют объекты на основе обших характеристик и поведения и определяют схему элементов, которая автоматиризует их создание.



### Проверка конструктора объектов с помощью ```instanceof```


Всякий раз, когда функция конструктора создает новый объект, этот объект называется экземпляром этого конструктора. JavaScript дает удобный способ проверить это с помощью оператора ```instanceof```. 

```instanceof``` позволяет сравнить объект с конструктором, возвращая значение ```true``` или ```false``` в зависимости от того, был ли этот объект создан с помощью конструктора.

Вот пример:

```javascript
let Bird = function(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}

let crow = new Bird("Alexis", "black");

crow instanceof Bird; // => true
```

Если объект создается без использования конструктора, ```instanceof``` проверяет, что он не является экземпляром этого конструктора:

```javascript
let canary = {
  name: "Mildred",
  color: "Yellow",
  numLegs: 2
};

canary instanceof Bird; // => false
```


### Понятие - собственные (```Own```) свойства


В следующем примере конструктор ```Bird``` определяет два свойства: ```name``` и ```numLegs```:

```javascript
function Bird(name) {
  this.name  = name;
  this.numLegs = 2;
}

let duck = new Bird("Donald");
let canary = new Bird("Tweety");
```

```name``` и ```numLegs``` называются собственными (```own```) свойствами, поскольку они определяются непосредственно на объекте экземпляра. Это означает, что ```duck``` и ```canary``` каждая еимеет свою собственную отдельную копию этих свойств. И на самом деле, каждый экземпляр ```Bird``` будет иметь свою собственную копию этих свойств. 

Следующий код добавляет все собственные (```own```) свойства из ```duck``` в массив ```ownProps```:

```javascript
let ownProps = [];

for (let property in duck) {
  if(duck.hasOwnProperty(property)) {
    ownProps.push(property);
  }
}

console.log(ownProps); // prints [ "name", "numLegs" ]
```


### Использование свойств прототипа (Prototype Properties) для уменьшения количества дубликатов кода


Поскольку ```numLegs```, вероятно, будет иметь одинаковое значение для всех экземпляров ```Bird```, у вас по существу есть дублированные переменные ```numLegs``` внутри каждого экземпляра ```Bird```.

Это не проблема, когда есть только 2 экземпляра, но представьте, если есть миллионы экземпляров. Это приведет к огромному количеству дублированных переменных.

Лучший способ заключается в использованние ```Bird's prototype```. Свойства прототипа (```prototype```) совместно используются всеми экземплярами ```Bird```. Вот как добавить ```numLegs``` к ```Bird prototype```:

```javascript
Bird.prototype.numLegs = 2;
```

Теперь все экземпляры ```Bird``` имеют свойство ```numLegs```.

```javascript
console.log(duck.numLegs);  // prints 2
console.log(canary.numLegs);  // prints 2
```

Поскольку все экземпляры автоматически имеют свойства прототипа, думайте о прототипе как о "рецепте" для создания объектов. Обратите внимание, что ```prototype``` для ```duck``` и ```canary``` является частью конструктора ```Bird``` как ```Bird.prototype```. Почти каждый объект в JavaScript имеет ```prototype``` свойство, которое является частью функции конструктора, которая его создала.



### Перебор всех свойств


Теперь вы увидели два вида свойств: собственные (```own```) свойства и  ```prototype``` свойства прототипа. Собственные свойства определяются непосредственно на самом экземпляре объета. А прототипные свойства определяются на ```prototype```.

```javascript
function Bird(name) {
  this.name = name;  //own property
}

Bird.prototype.numLegs = 2; // prototype property

let duck = new Bird("Donald");
```

Ниже вы добавляете собственные свойства ```duck``` в массив ```iwnProps``` и свойства прототипа в массива ```prototypeProps```: 

```javascript
let ownProps = [];
let prototypeProps = [];

for (let property in duck) {
  if(duck.hasOwnProperty(property)) {
    ownProps.push(property);
  } else {
    prototypeProps.push(property);
  }
}

console.log(ownProps); // prints ["name"]
console.log(prototypeProps); // prints ["numLegs"]
```


### Понятие - свойства конструктора


Существую специальное свойство конструктора (```constructor```), расположенное на экземплярах объекта ```duck``` и ```beagle```, созданных в предыдущих задачах:

```javascript
for (let property in duck) {
  if(duck.hasOwnProperty(property)) {
    ownProps.push(property);
  } else {
    prototypeProps.push(property);
  }
}
```

Обратите внимание, что свойство ```constructor``` является ссылкой на функцию конструктора, который создал этот экземпляр. Приемущество свойства ```constructor``` заключается в том, что можно проверить это свойство для понимания, что это за объект. Вот пример того, как это можно было бы использовать:

```javascript
function joinBirdFraternity(candidate) {
  if (candidate.constructor === Bird) {
    return true;
  } else {
    return false;
  }
}
```

Внимание
Поскольу свойство ```constructor``` может быть перезаписано (что будет рассмотрено в следующих двух задачах), обычно лучше использовать метод ```instanceof``` для проверки типа объекта.


### Изменение ```prototype``` на новый объект


До сих пор вы добавляли свойства к ```prototype``` по отдельности:

```javascript
Bird.prototype.numLegs = 2;
```

Это станет утомительным, если нужно будет добавить более пары свойств:

```javascript
Bird.prototype.eat = function() {
  console.log("nom nom nom");
}

Bird.prototype.describe = function() {
  console.log("My name is " + this.name);
}
```

Более эффективным способом является установка ```prototype``` как новый объект, который уже содержит свойства. Таким образом можно добавить сразу множество свойств:

```javascript
Bird.prototype = {
  numLegs: 2, 
  eat: function() {
    console.log("nom nom nom");
  },
  describe: function() {
    console.log("My name is " + this.name);
  }
};
```


### Не забывайте устанавливать свойство ```constructor``` при изменение ```prototype```







[Вернутся назад](../README.md)