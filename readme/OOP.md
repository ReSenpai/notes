## Объектно ориентированное программирование

### Создание базоовго JS объекта

Подумайте о вещах, которые люди видят каждый день, таких как автомобили, магазины и птицы. Это все объекты, осязаемые вещи, которые люди могут наблюдать и взаимодействовать.

Каковы некоторые качества этих объектов? У машины есть колеса. Магазины продают товары. У птиц есть крылья.

Эти качества, или свойства, определяют то, что составляет объект. Обратите внимание, что подобные объекты имеют одинаковые свойства, но могут иметь разные значения для этих свойств. Например, все автомобили имеют колеса, но не все автомобилиимеют одинаковое количество колес.

Объекты в JS используются для моделирования объектов реального мира, придавая им такие же свойства и поведение, как их реальные аналоги. Вот например использования этих понятий для создания объекта ```duck```:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2
};
```

Этот объект утки имеет два свойства: Имя: "Aflac" и количество ног: 2


### Использование точечной нотации для доступа к свойствам объекта

Выше мы создали объект с разными свойствами. Теперь мы увидим, как получить доступ к значениям этих свойств. Вот например:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2
};
console.log(duck.name);
// This prints "Aflac" to the console
```

Точечная нотация используется на Имя объекта ```duck```, а затем имя свойства ```name```, чтобы получит доступ к значению ```"Aflac"```.


### Создание метода для объекта


Объекты могут иметь специальный тип свойства, назывыемый методом.

Методы - это свойства, которые являются функциями. Это добавляет другое поведение объекту. Вот пример объекта ```duck``` с методом:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {return "The name of this duck is " + duck.name + ".";}
};
duck.sayName();
// Returns "The name of this duck is Aflac."
```

В этом примере добавляется метод ```sayName```, который представляет собой функцию, возвращающую предложение с именем утки. Обратите внимание, что метод получил доступ к свойству ```name``` в операторе ```return``` с помощью ```duck.name```; Следующая задача покажет другой способ сделать это.



### Сделать код многоразовым с помощью ключевого слова ```this```


Пример выше ввел метод для объекта ```duck```. Он использовал точечную нотацию ```duck.name``` для доступа к значению свойства ```name``` в операторе ```return```:

```sayName: function() {return "The name of this duck is " + duck.name + ".";}```

Хоть это и допустимый способ доступа к свойству объекта, здесь есть ловушка. Если имя переменной изменяется, любой код, ссылающийся на исходное имя, так же должен быть обновлен. В коротком определении объекта это не проблема, но если объект имеет много ссылок на его свойства, существует довольно большая вероятность ошибки.

Способ избежать эти проблемы заключается в использовании ключевого слова ```this```:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {return "The name of this duck is " + this.name + ".";}
};
```

```this``` это глубокая тема, и приведенный выше пример является только одним из способов его использования. В текущем контексте это относится к объекту, с которым связан метод: ```duck```. Если имя объекта изменится на ```mallard```, нет необходимости искать все ссылки на ```duck``` в коде. Это делает код более читаемым и многоразовым.


### Определение функции конструктора


Конструкторы - это функции, которые создают новые объекты. Они определяют свойства и поведение, которые будут принадлежать новому объекту. Думайте о них как о плане создания новых объектов.

Вот пример конструктора:

```javascript
function Bird() {
  this.name = "Albert";
  this.color = "blue";
  this.numLegs = 2;
}
```

Этот конструктор определяет объект ```Bird``` со свойствами ```name```, ```color``` и ```numLegs```, равными ```"Albert"```, ```blue``` и ```2``` соотвественно. Конструкторы следуют нескольким соглашениям:

- Конструкторы определяются с заглавным именем, чтобы отличать их от других функций, которые не являются конструкторами.

- Конструкторы используют ключевое слово ```this```, чтобы задавать свойства объекта, который они создают. Внутри конструктора, ```this``` относится к новому объекту, который он создает.

- Конструкторы определяют свойства и поведение, а не возвращают значение, как другие функции.


### Использование конструктора для создания объектов


Вот ```Bird``` конструктор из предыдущей задачи:

```javascript
function Bird() {
  this.name = "Albert";
  this.color  = "blue";
  this.numLegs = 2;
  // "this" inside the constructor always refers to the object being created
}

let blueBird = new Bird();
```

Обратите внимание, что оператор ```new``` используется при вызове конструктора. Это говорит JavaScript-у, что нужно создать новый экземпляр ```Bird``` по названием ```blueBird```. Без оператора ```new```, ```this``` внутри конструктора не указывало бы на вновь созданный объект, давая неожиданные результаты. Теперь ```blueBird``` имеет все свойства, определенные внутри конструктора ```Bird```:

```javascript
blueBird.name; // => Albert
blueBird.color; // => blue
blueBird.numLegs; // => 2
```

Как и любой другой объект, его свойства могут быть получены и изменены:

```javascript
blueBird.name = 'Elvira';
blueBird.name; // => Elvira
```


### Расширение конструкторов для получения аргументов






[Вернутся назад](../README.md)