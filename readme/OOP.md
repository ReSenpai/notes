# Объектно ориентированное программирование

1. [Создание базового объекта](#создание-базоовго-js-объекта)  
2. [Использование точечной нотации для доступа к свойствам объекта](#использование-точечной-нотации-для-доступа-к-свойствам-объекта)  
3. [Создание метода для объекта](#создание-метода-для-объекта)  
4. [Сделать код многоразовым с помощью ключевого слова this](#сделать-код-многоразовым-с-помощью-ключевого-слова-this)  
5. [Определение функции конструктора](#определение-функции-конструктора)  
6. [Использование конструктора для создания объектов](#использование-конструктора-для-создания-объектов)  
7. [Расширение конструкторов для получения аргументов](#расширение-конструкторов-для-получения-аргументов)  
8. [Проверка конструктора объектов с помощью instanceof](#проверка-конструктора-объектов-с-помощью-instanceof)  
9. [Понятие - собственные (Own) свойства](#понятие---собственные-own-свойства)  
10. [Использование свойств прототипа (Prototype Properties) для уменьшения количества дубликатов кода](#использование-свойств-прототипа-prototype-properties-для-уменьшения-количества-дубликатов-кода)  
11. [Перебор всех свойств](#перебор-всех-свойств)  
12. [Понятие - свойства конструктора](#понятие---свойства-конструктора)  
13. [Изменение prototype на новый объект](#изменение-prototype-на-новый-объект)  
14. [Не забывайте устанавливать свойство constructor при изменение prototype](#не-забывайте-устанавливать-свойство-constructor-при-изменение-prototype)

#

## Создание базового JS объекта

Подумайте о вещах, которые люди видят каждый день, таких как автомобили, магазины и птицы. Это все объекты, осязаемые вещи, которые люди могут наблюдать и взаимодействовать.

Каковы некоторые качества этих объектов? У машины есть колеса. Магазины продают товары. У птиц есть крылья.

Эти качества, или свойства, определяют то, что составляет объект. Обратите внимание, что подобные объекты имеют одинаковые свойства, но могут иметь разные значения для этих свойств. Например, все автомобили имеют колеса, но не все автомобили имеют одинаковое количество колес.

Объекты в JS используются для моделирования объектов реального мира, придавая им такие же свойства и поведение, как их реальные аналоги. Вот например использования этих понятий для создания объекта ```duck```:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2
};
```

Этот объект утки имеет два свойства: Имя: "Aflac" и количество ног: 2


## Использование точечной нотации для доступа к свойствам объекта
[Вверх](#объектно-ориентированное-программирование) 

Выше мы создали объект с разными свойствами. Теперь мы увидим, как получить доступ к значениям этих свойств. Вот например:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2
};
console.log(duck.name);
// This prints "Aflac" to the console
```

Точечная нотация используется на Имя объекта ```duck```, а затем имя свойства ```name```, чтобы получит доступ к значению ```"Aflac"```.


## Создание метода для объекта 
[Вверх](#объектно-ориентированное-программирование) 


Объекты могут иметь специальный тип свойства, назывыемый методом.

Методы - это свойства, которые являются функциями. Это добавляет другое поведение объекту. Вот пример объекта ```duck``` с методом:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {return "The name of this duck is " + duck.name + ".";}
};
duck.sayName();
// Returns "The name of this duck is Aflac."
```

В этом примере добавляется метод ```sayName```, который представляет собой функцию, возвращающую предложение с именем утки. Обратите внимание, что метод получил доступ к свойству ```name``` в операторе ```return``` с помощью ```duck.name```; Следующая задача покажет другой способ сделать это.



## Сделать код многоразовым с помощью ключевого слова ```this```
[Вверх](#объектно-ориентированное-программирование) 


Пример выше ввел метод для объекта ```duck```. Он использовал точечную нотацию ```duck.name``` для доступа к значению свойства ```name``` в операторе ```return```:

```sayName: function() {return "The name of this duck is " + duck.name + ".";}```

Хоть это и допустимый способ доступа к свойству объекта, здесь есть ловушка. Если имя переменной изменяется, любой код, ссылающийся на исходное имя, так же должен быть обновлен. В коротком определении объекта это не проблема, но если объект имеет много ссылок на его свойства, существует довольно большая вероятность ошибки.

Способ избежать эти проблемы заключается в использовании ключевого слова ```this```:

```javascript
let duck = {
  name: "Aflac",
  numLegs: 2,
  sayName: function() {return "The name of this duck is " + this.name + ".";}
};
```

```this``` это глубокая тема, и приведенный выше пример является только одним из способов его использования. В текущем контексте это относится к объекту, с которым связан метод: ```duck```. Если имя объекта изменится на ```mallard```, нет необходимости искать все ссылки на ```duck``` в коде. Это делает код более читаемым и многоразовым.


## Определение функции конструктора
[Вверх](#объектно-ориентированное-программирование) 


Конструкторы - это функции, которые создают новые объекты. Они определяют свойства и поведение, которые будут принадлежать новому объекту. Думайте о них как о плане создания новых объектов.

Вот пример конструктора:

```javascript
function Bird() {
  this.name = "Albert";
  this.color = "blue";
  this.numLegs = 2;
}
```

Этот конструктор определяет объект ```Bird``` со свойствами ```name```, ```color``` и ```numLegs```, равными ```"Albert"```, ```blue``` и ```2``` соотвественно. Конструкторы следуют нескольким соглашениям:

- Конструкторы определяются с заглавным именем, чтобы отличать их от других функций, которые не являются конструкторами.

- Конструкторы используют ключевое слово ```this```, чтобы задавать свойства объекта, который они создают. Внутри конструктора, ```this``` относится к новому объекту, который он создает.

- Конструкторы определяют свойства и поведение, а не возвращают значение, как другие функции.


## Использование конструктора для создания объектов
[Вверх](#объектно-ориентированное-программирование) 


Вот ```Bird``` конструктор из предыдущей задачи:

```javascript
function Bird() {
  this.name = "Albert";
  this.color  = "blue";
  this.numLegs = 2;
  // "this" inside the constructor always refers to the object being created
}

let blueBird = new Bird();
```

Обратите внимание, что оператор ```new``` используется при вызове конструктора. Это говорит JavaScript-у, что нужно создать новый экземпляр ```Bird``` по названием ```blueBird```. Без оператора ```new```, ```this``` внутри конструктора не указывало бы на вновь созданный объект, давая неожиданные результаты. Теперь ```blueBird``` имеет все свойства, определенные внутри конструктора ```Bird```:

```javascript
blueBird.name; // => Albert
blueBird.color; // => blue
blueBird.numLegs; // => 2
```

Как и любой другой объект, его свойства могут быть получены и изменены:

```javascript
blueBird.name = 'Elvira';
blueBird.name; // => Elvira
```


## Расширение конструкторов для получения аргументов
[Вверх](#объектно-ориентированное-программирование) 


В ```Bird``` конструкторы из последнего вызова работали хорошо. Однако обратите внимание, что все ```Birds```, созданные с помощью конструктора ```Bird```, автоматически называются Альберт, имеют синий цвет и две ноги. 

Что делать, если вам нужны птицы с разными значениями имени и цвета? Можно изменить свойства каждой птицы вручную, но это будет слишком долго:

```javascript
let swan = new Bird();
swan.name = "Carlos";
swan.color = "white";
```

Предположим, вы пишете программу для отслеживания сотен или даже тысяч различных птиц в вольере. Это займет слишком много времени, чтобы создать всех птиц, а затем изменить свойства на разные значения для каждой из них. 

Чтобы легче создавать различные объекты ```Bird```, вы можете заставить свой конструктор  ```Bird``` принимать параметры:

```javascript
function Bird(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}
```

Затем передайте значения в качестве аргументов для определения каждой уникальной птицы в конструктор ```Bird```: ```let cardinal = new Bird("Bruce", "red");``` Это дает новый экземпляр ```Bird``` со свойствами ```name``` и ```color```, установленными в ```"Bruce"``` и ```"red"``` соответственно. Свойство ```numLegs``` по прежнему имеет значение 2.

```cardinal``` обладает такими свойствами:

```javascript
cardinal.name // => Bruce
cardinal.color // => red
cardinal.numLegs // => 2
```

Такой конструктор является более гибким. Теперь можно определить свойства для каждого экземпляра ```Bird``` во время его создания, что является одним из полезнейших приемуществ использования конструкторов в JavaScript. Они группируют объекты на основе обших характеристик и поведения и определяют схему элементов, которая автоматиризует их создание.



## Проверка конструктора объектов с помощью ```instanceof```
[Вверх](#объектно-ориентированное-программирование) 


Всякий раз, когда функция конструктора создает новый объект, этот объект называется экземпляром этого конструктора. JavaScript дает удобный способ проверить это с помощью оператора ```instanceof```. 

```instanceof``` позволяет сравнить объект с конструктором, возвращая значение ```true``` или ```false``` в зависимости от того, был ли этот объект создан с помощью конструктора.

Вот пример:

```javascript
let Bird = function(name, color) {
  this.name = name;
  this.color = color;
  this.numLegs = 2;
}

let crow = new Bird("Alexis", "black");

crow instanceof Bird; // => true
```

Если объект создается без использования конструктора, ```instanceof``` проверяет, что он не является экземпляром этого конструктора:

```javascript
let canary = {
  name: "Mildred",
  color: "Yellow",
  numLegs: 2
};

canary instanceof Bird; // => false
```


## Понятие - собственные (```Own```) свойства
[Вверх](#объектно-ориентированное-программирование) 


В следующем примере конструктор ```Bird``` определяет два свойства: ```name``` и ```numLegs```:

```javascript
function Bird(name) {
  this.name  = name;
  this.numLegs = 2;
}

let duck = new Bird("Donald");
let canary = new Bird("Tweety");
```

```name``` и ```numLegs``` называются собственными (```own```) свойствами, поскольку они определяются непосредственно на объекте экземпляра. Это означает, что ```duck``` и ```canary``` каждая еимеет свою собственную отдельную копию этих свойств. И на самом деле, каждый экземпляр ```Bird``` будет иметь свою собственную копию этих свойств. 

Следующий код добавляет все собственные (```own```) свойства из ```duck``` в массив ```ownProps```:

```javascript
let ownProps = [];

for (let property in duck) {
  if(duck.hasOwnProperty(property)) {
    ownProps.push(property);
  }
}

console.log(ownProps); // prints [ "name", "numLegs" ]
```


## Использование свойств прототипа (Prototype Properties) для уменьшения количества дубликатов кода
[Вверх](#объектно-ориентированное-программирование) 


Поскольку ```numLegs```, вероятно, будет иметь одинаковое значение для всех экземпляров ```Bird```, у вас по существу есть дублированные переменные ```numLegs``` внутри каждого экземпляра ```Bird```.

Это не проблема, когда есть только 2 экземпляра, но представьте, если есть миллионы экземпляров. Это приведет к огромному количеству дублированных переменных.

Лучший способ заключается в использованние ```Bird's prototype```. Свойства прототипа (```prototype```) совместно используются всеми экземплярами ```Bird```. Вот как добавить ```numLegs``` к ```Bird prototype```:

```javascript
Bird.prototype.numLegs = 2;
```

Теперь все экземпляры ```Bird``` имеют свойство ```numLegs```.

```javascript
console.log(duck.numLegs);  // prints 2
console.log(canary.numLegs);  // prints 2
```

Поскольку все экземпляры автоматически имеют свойства прототипа, думайте о прототипе как о "рецепте" для создания объектов. Обратите внимание, что ```prototype``` для ```duck``` и ```canary``` является частью конструктора ```Bird``` как ```Bird.prototype```. Почти каждый объект в JavaScript имеет ```prototype``` свойство, которое является частью функции конструктора, которая его создала.



## Перебор всех свойств
[Вверх](#объектно-ориентированное-программирование) 


Теперь вы увидели два вида свойств: собственные (```own```) свойства и  ```prototype``` свойства прототипа. Собственные свойства определяются непосредственно на самом экземпляре объета. А прототипные свойства определяются на ```prototype```.

```javascript
function Bird(name) {
  this.name = name;  //own property
}

Bird.prototype.numLegs = 2; // prototype property

let duck = new Bird("Donald");
```

Ниже вы добавляете собственные свойства ```duck``` в массив ```iwnProps``` и свойства прототипа в массива ```prototypeProps```: 

```javascript
let ownProps = [];
let prototypeProps = [];

for (let property in duck) {
  if(duck.hasOwnProperty(property)) {
    ownProps.push(property);
  } else {
    prototypeProps.push(property);
  }
}

console.log(ownProps); // prints ["name"]
console.log(prototypeProps); // prints ["numLegs"]
```


## Понятие - свойства конструктора
[Вверх](#объектно-ориентированное-программирование) 


Существую специальное свойство конструктора (```constructor```), расположенное на экземплярах объекта ```duck``` и ```beagle```, созданных в предыдущих задачах:

```javascript
for (let property in duck) {
  if(duck.hasOwnProperty(property)) {
    ownProps.push(property);
  } else {
    prototypeProps.push(property);
  }
}
```

Обратите внимание, что свойство ```constructor``` является ссылкой на функцию конструктора, который создал этот экземпляр. Приемущество свойства ```constructor``` заключается в том, что можно проверить это свойство для понимания, что это за объект. Вот пример того, как это можно было бы использовать:

```javascript
function joinBirdFraternity(candidate) {
  if (candidate.constructor === Bird) {
    return true;
  } else {
    return false;
  }
}
```

Внимание
Поскольу свойство ```constructor``` может быть перезаписано (что будет рассмотрено в следующих двух задачах), обычно лучше использовать метод ```instanceof``` для проверки типа объекта.


## Изменение ```prototype``` на новый объект
[Вверх](#объектно-ориентированное-программирование) 


До сих пор вы добавляли свойства к ```prototype``` по отдельности:

```javascript
Bird.prototype.numLegs = 2;
```

Это станет утомительным, если нужно будет добавить более пары свойств:

```javascript
Bird.prototype.eat = function() {
  console.log("nom nom nom");
}

Bird.prototype.describe = function() {
  console.log("My name is " + this.name);
}
```

Более эффективным способом является установка ```prototype``` как новый объект, который уже содержит свойства. Таким образом можно добавить сразу множество свойств:

```javascript
Bird.prototype = {
  numLegs: 2, 
  eat: function() {
    console.log("nom nom nom");
  },
  describe: function() {
    console.log("My name is " + this.name);
  }
};
```


## Не забывайте устанавливать свойство ```constructor``` при изменение ```prototype```
[Вверх](#объектно-ориентированное-программирование) 


Существует один важный побочный эффект ручной установки ```prototype``` как новый объект. Он стирает свойство ```constructor```! Это свойство можно использовать для проверки того, какая функция конструктора создала экземпляр, но поскольку свойство было перезаписано, оно теперь дает ложные результаты:

```javascript
duck.constructor === Bird; // false -- Oops
duck.constructor === Object; // true, all objects inherit from Object.prototype
duck instanceof Bird; // true, still works
```

Чтобы исправить это, всякий раз, когда ```prototype``` вручную устанавливается как новый объект, не забудьте определить свойство ```constructor```:

```javascript
Bird.prototype = {
  constructor: Bird, // define the constructor property
  numLegs: 2,
  eat: function() {
    console.log("nom nom nom");
  },
  describe: function() {
    console.log("My name is " + this.name); 
  }
};
```


## Понять, откуда берется прототип объекта (```prototype```)
[Вверх](#объектно-ориентированное-программирование) 


Точно так же, как люди наследуют гены от своих родителей, объект наследует свой ```prototype``` непосредственно от функции конструктора, которая его создала. Например, здесь конструктор ```Bird``` создает объект ```duck```:

```javascript
function Bird(name) {
  this.name = name;
}

let duck = new Bird("Donald");
```

```duck``` наследует свой ```prototype``` от функции конструктора ```Bird```. Вы можете увидеть эту связь с помощью метода ```isPrototypeOf```:

```javascript
Bird.prototype.isPrototypeOf(duck);
// returns true
```


## Понять цепочку ```prototype```
[Вверх](#объектно-ориентированное-программирование) 


Все объекты в JavaScript (за редким исключением) имеют прототип (```prototype```). Кроме того, прототип самого объекта является объектом.

```javascript
function Bird(name) {
  this.name = name;
}

typeof Bird.prototype; // yields 'object'
```

Поскольку прототип - это объект, прототип может иметь свой собственный прототип. В данном случае прототип ```Bird.prototype``` это ```Object.prototype```:

```javascript
Object.prototype.isPrototypeOf(Bird.prototype); // returns true
```

Насколько это полезно? Вы можете вспомнить метод ```hasOwnProperty``` из предыдущей задачи:

```javascript
let duck = new Bird("Donald");
duck.hasOwnProperty("name"); // yields true
```

Метод ```hasOwnProperty``` определен в ```Object.prototype```, к которому может получить доступ ```Bird.prototype```, к которому затем может получить доступ ```duck```. Это пример цепочки прототив. В это цепочке прототипов ```Bird``` является супертипом (```supertype```) для ```duck```, а ```duck``` - подтипом (```subtype```).

```Object``` это супертип(```supertype```) как для ```Bird```, так и для ```duck```.

 ```Object``` является супертипом для всех объектов в JavaScript. Поэтому любой объект может использовать метод ```hasOwnProperty```.



## Использование наследования для избежания повторов
[Вверх](#объектно-ориентированное-программирование) 


В программировании есть принцип, который называется "Не повторяйся" (DRY от Don't Repeat Yourself). Причина, по которой повторяющийся код является проблемой, заключается в том, что любое изменение требует изменения кода в нескольких местах. Это обычно означает больше работы для программистов, а значит больше места для ошибок.

Обратите внимани, что в приведенной ниже примере метод ```describe``` используется совсместно в ```Bird``` и ```Dog```:

```javascript
Bird.prototype = {
  constructor: Bird,
  describe: function() {
    console.log("My name is " + this.name);
  }
};

Dog.prototype = {
  constructor: Dog,
  describe: function() {
    console.log("My name is " + this.name);
  }
};
```

Метод ```describe``` повторяется в двух местах. Код можно отредактировать, чтобы соблюсти DRY принцип, создав ```supertype``` (или родитель) под названием ```Animal```:

```javascript
function Animal() {

    Animal.prototype = {
        constructor: Animal, 
        describe: function() {
        console.log("My name is " + this.name);
        }
    }
};
```

Поскольку ```Animal``` включает в себя метод ```describe```, вы можете удалить его из ```Bird``` и ```Dog```:

```javascript
Bird.prototype = {
  constructor: Bird
};

Dog.prototype = {
  constructor: Dog
};
```


## Наследование поведения супертипа (```supertype```)
[Вверх](#объектно-ориентированное-программирование) 


В предыдущей задаче вы создали супертип - ```Animal```, который определяет поведение, общее для всех животных:

```javascript
function Animal() { }
Animal.prototype.eat = function() {
  console.log("nom nom nom");
};
```

Эта и следующая задача будут касаться того, как повторно использовать методы ```Animal's``` внутри ```Bird``` и ```Dog```, не определяя их снова. Это будет техника, называемая наследованием. Эта задача охватывает первый шаг: создание эземпляра супертипа (```supertype``` или родителя). Вы уже знаете один способ создать экземпляр ```Animal``` используя оператор ```new```:

```javascript
let animal = new Animal();
```

Есть некоторые недостатки при использовании этого синтаксиса для наследования, которые становятся слишком сложными для масштабов этой задачи. Вместо этого есть альтернативный подход, исключающий эти недостатки:

```javascript
let animal = Object.create(Animal.prototype);
```

```Object.create(obj)``` создает новый объект и устанавлвиает ```obj``` в качестве прототипа нового объекта. Напомним, что прототип - это как бы "рецепт" для создания объектов. 

Установив прототип для ```animal``` в качестве ```Animal's prototype```, вы фактически даете экземпляру ```animal``` тот же "рецепт", что и любой другой экземпляр ```Animal```.

```javascript
animal.eat(); // prints "nom nom nom"
animal instanceof Animal; // => true
```


## Установка родительского экземпляра для дочернего прототипа
[Вверх](#объектно-ориентированное-программирование) 


В предыдущей задаче вы видели первый шаг для наследования поведения от супертипа (или родителя) ```Animal```: создание нового экземпляра ```Animal```.

Эта задача охватывает следующий шаг: установите ```prototype``` подтипа (или ребенка) - в данном случае ```Bird``` в качестве экземпляра ```Animal```.

```javascript
Bird.prototype = Object.create(Animal.prototype);
```

Помните, что прототип - это как бы "рецепт" для создания объекта. В каком то смысле рецепт для ```Bird``` включает в себя все ключевые "ингредиенты" от ```Animal```.


```javascript
let duck = new Bird("Donald");
duck.eat(); // prints "nom nom nom"
```

```duck``` наследует все свойства ```Animal```, включая метод ```eat```.


```javascript
function Animal() { }

Animal.prototype = {
  constructor: Animal,
  eat: function() {
    console.log("nom nom nom");
  }
};

function Dog() { 
  Dog.prototype = Object.create(Animal.prototype);
}


let beagle = new Dog();
```

## Сброс унаследованного свойства конструктора
[Вверх](#объектно-ориентированное-программирование) 


Когда объект наследует свой прототип от другого объекта, он также наследует свойства конструктора супертипа.

Вот такой пример:

```javascript
function Bird() { }
Bird.prototype = Object.create(Animal.prototype);
let duck = new Bird();
duck.constructor // function Animal(){...}
```

Но ```duck``` и все экземпляры ```Bird``` должны показать, что они были построены ```Bird```, а не ```Animal```. Чтобы сделать это, вы можете вручную установить свойство конструктора ```Bird``` к объекту ```Bird```:

```javascript
Bird.prototype.constructor = Bird;
duck.constructor // function Bird(){...}
```


## Добавление методов после наследования
[Вверх](#объектно-ориентированное-программирование) 


Функция конструктор, наследующая объект ```прототип``` от функции конструктора ```супертипа```, может иметь собсвтенные методы в дополнение к унаследованным методам.

Например, ```Bird``` это конструктор, который наследует свой прототип от ```Animal```:

```javascript
function Animal() { }
Animal.prototype.eat = function() {
  console.log("nom nom nom");
};
function Bird() { }
Bird.prototype = Object.create(Animal.prototype);
Bird.prototype.constructor = Bird;
```

В дополннеие к тому, что унаследовано от ```Animal```, вы хотите добавить поведение, уникальное для объектов ```Bird```. Здесь ```Bird``` получит функцию ```fly()```. Функции добавляются в прототип птицы так же, как и любая функция констроктора:

```javascript
Bird.prototype.fly = function() {
  console.log("I'm flying!");
};
```

Теперь экземпляры ```Bird``` будут иметь методы ```eat()``` и ```fly()```:


```javascript
let duck = new Bird();
duck.eat(); // prints "nom nom nom"
duck.fly(); // prints "I'm flying!"
```


```javascript
function Animal() { }
Animal.prototype.eat = function() { console.log("nom nom nom"); };

function Dog() { }

// Only change code below this line
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
Dog.prototype.bark = function() {
  console.log("Woof!");
};


// Only change code above this line

let beagle = new Dog();
```


## Переопределение унаследованных методов
[Вверх](#объектно-ориентированное-программирование) 

В предыдущих уроках вы узнали, что объект может наследовать свое поведение (методы) от другого объекта, ссылаясь на свой ```прототип``` объекта:

```javascript
ChildObject.prototype = Object.create(ParentObject.prototype);
```

Затем ```ChildObject``` получил свои собственные методы, приковав их к своему ```прототипу```:

```javascript
ChildObject.prototype.methodName = function() {...};
```

Можно переопределить унаследованный метод. Это делается таким же образом - путем добавления метода в ```ChildObject.prototype```, используещего то же имя метода, что и переопределяемый. Вот пример переопределения в ```Bird``` метода ```eat()```, унаследованного от ```Animal```:

```javascript
function Animal() { }
Animal.prototype.eat = function() {
  return "nom nom nom";
};
function Bird() { }

// Inherit all methods from Animal
Bird.prototype = Object.create(Animal.prototype);

// Bird.eat() overrides Animal.eat()
Bird.prototype.eat = function() {
  return "peck peck peck";
};
```

Если у вас есть экземпляр ```let duck = new Bird();``` и вы вызываете ```duck.eat()```,  то именно так JavaScript будет икать метод в цепочке прототипов ```duck```:

1. duck => Определяется ли здесь eat()? Нет.
2. Bird => Определяется ли здесь eat()? => Да. Выполни его и прекрати поиск
3. Animal => eat() также определен, но JavaScript прекратил поиск, не достигнув этого уровня.
4. Object => JavaScript прекратил поиск, не достигнув этого уровня.


## Используйте mixin для добавления общего поведения между несвязанными объектами
[Вверх](#объектно-ориентированное-программирование) 


Как вы выдели, поведение передается по наследству. Однако бывают случаи, когда наследование не является лучшим решением. Наследование плохо работает для несвязанных объектов, таких как ```Птица``` и ```Самолет```. Они оба могут летать, но птица не является типом ```Самолета``` и наоборот.

Для несвязанных объектов лучше использовать ```миксины```. ```Mixin``` позволяет другим объектам использовать набор функций.

```javascript
let flyMixin = function(obj) {
  obj.fly = function() {
    console.log("Flying, wooosh!");
  }
};
```

```fkyMixin``` берет любой объект и дает ему метод ```fly```.


```javascript
let bird = {
  name: "Donald",
  numLegs: 2
};

let plane = {
  model: "777",
  numPassengers: 524
};

flyMixin(bird);
flyMixin(plane);
```

Здесь ```bird``` и ```plane``` передаются в ```flyMixin```, который затем присваивает функцию ```fly``` каждому объекту. Тепер ```bird``` и ```plane``` могут летать вместе:


```javascript
bird.fly(); // prints "Flying, wooosh!"
plane.fly(); // prints "Flying, wooosh!"
```

Обратите внимание, как mixin позволяет использовать один и тот же метод ```fly``` для повторного использования несвязанными объектами ```bird``` и ```plane```.


## Использование замыкания для защиты свойств внутри объекта от внешнего изменения
[Вверх](#объектно-ориентированное-программирование) 


В предыдущем вызове у ```Bird``` было имя публичной собственности. Оно считается общедоступным, потому что к нему можно получить доступ и изменить его вне определения ```Bird```.

```javascript
bird.name = "Duffy";
```

Поэтому любая часть вашего кода может легко изменить имя ```bird``` на любое значение. Подумайте о таких вещах, как пароли и банковские счета, которые легко изменить с помощью любой части вашей кодовой базы. Это может вызвать много проблем.

Самый простой способ сделать это публичное свойство - приватным, создать переменную в функции конструктора. Это изменяет область действия этой переменной в пределах функции конструктора по сравнению с глобально доступной. Таким образом, переменная может быть доступна и изменена только методами, также находяшимися в функции конструктора.


```javascript
function Bird() {
  let hatchedEgg = 10; // private variable

  /* publicly available method that a bird object can use */
  this.getHatchedEggCount = function() { 
    return hatchedEgg;
  };
}
let ducky = new Bird();
ducky.getHatchedEggCount(); // returns 10
```

Здесь ```getHatchedEggCount``` является привилегированным методом, поскольку он имеет доступ к частной переменной ```hatchedEgg```. Это возможно, потому что ```hatchedEgg``` объявлен в том же контексте, что и ```getHatchedEggCount```. В JavaScript функция всегда имеет доступ к контексту, в котором она была создана. Это называется закрытием (```closure```).


## Понятие - сразу вызывается функция выражение (IIFE от Immediately Invoked Function Expression)
[Вверх](#объектно-ориентированное-программирование) 


Общий шаблон в JavaScript для того, чтобы выполнить функцию, как только она объявлена:

```javascript
(function () {
  console.log("Chirp, chirp!");
})(); // this is an anonymous function expression that executes right away
// Outputs "Chirp, chirp!" immediately
```

Обратите внимание, что функция не имеет имени и не храниться в переменной. Две круглые скобки () в конце выражения функции вызывают его немедленное выполнение или вызов. Эта закономерность известна как сразу же вызываемая функция выражения ил IIFE.



## Использование IIFE для создания модуля
[Вверх](#объектно-ориентированное-программирование) 


Выражение немедленно вызываемой функции (IIFE) часто используется для группировки связанных функциональных возможностей в один объект или модуль. Например, более рання задача определила два миксина:

```javascript
function glideMixin(obj) {
  obj.glide = function() {
    console.log("Gliding on the water");
  };
}
function flyMixin(obj) {
  obj.fly = function() {
    console.log("Flying, wooosh!");
  };
}
```

Мы можем сгруппировать эти миксины в модуль следующим образом: 

```javascript
let motionModule = (function () {
  return {
    glideMixin: function(obj) {
      obj.glide = function() {
        console.log("Gliding on the water");
      };
    },
    flyMixin: function(obj) {
      obj.fly = function() {
        console.log("Flying, wooosh!");
      };
    }
  }
})(); // The two parentheses cause the function to be immediately invoked
```

Обратите внимание, что у вас сразу же вызывается функция выражения (IIFE), которая возвращает объект ```motionModule```. Этот возвращаемый объект содержит все поведения mixin как свойства объекта. Преимущество шаблона модуля заключается в том, что все модели движения могут быть упакованы в один объект, который затем может использоваться другими частями кода. Вот пример его использования:

```javascript
motionModule.glideMixin(duck);
duck.glide();
```



 


[Вернутся назад](../README.md)